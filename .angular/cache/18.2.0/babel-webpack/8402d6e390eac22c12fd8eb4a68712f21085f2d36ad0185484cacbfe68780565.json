{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, booleanAttribute, TemplateRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Inject, ViewChild, ContentChildren, Input, Output, Directive, forwardRef, inject, Injector, afterNextRender, Optional, Host, NgModule } from '@angular/core';\nimport { MAT_OPTION_PARENT_COMPONENT, MatOption, MAT_OPTGROUP, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\nconst _c0 = [\"panel\"];\nconst _c1 = [\"*\"];\nfunction MatAutocomplete_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 1, 0);\n    i0.ɵɵlistener(\"@panelAnimation.done\", function MatAutocomplete_ng_template_0_Template_div_animation_panelAnimation_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._animationDone.next($event));\n    });\n    i0.ɵɵprojection(2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const formFieldId_r3 = ctx.id;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r1._classList);\n    i0.ɵɵclassProp(\"mat-mdc-autocomplete-visible\", ctx_r1.showPanel)(\"mat-mdc-autocomplete-hidden\", !ctx_r1.showPanel)(\"mat-primary\", ctx_r1._color === \"primary\")(\"mat-accent\", ctx_r1._color === \"accent\")(\"mat-warn\", ctx_r1._color === \"warn\");\n    i0.ɵɵproperty(\"id\", ctx_r1.id)(\"@panelAnimation\", ctx_r1.isOpen ? \"visible\" : \"hidden\");\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.ariaLabel || null)(\"aria-labelledby\", ctx_r1._getPanelAriaLabelledby(formFieldId_r3));\n  }\n}\nexport { MatOptgroup, MatOption } from '@angular/material/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i3 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { ActiveDescendantKeyManager, removeAriaReferencedId, addAriaReferencedId } from '@angular/cdk/a11y';\nimport * as i1 from '@angular/cdk/platform';\nimport { _getEventTarget } from '@angular/cdk/platform';\nimport { trigger, state, style, transition, group, animate } from '@angular/animations';\nimport { Subscription, Subject, defer, merge, of, fromEvent, Observable } from 'rxjs';\nimport { ESCAPE, hasModifierKey, UP_ARROW, ENTER, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\nimport { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport * as i4 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD } from '@angular/material/form-field';\nimport { startWith, switchMap, filter, map, tap, delay, take } from 'rxjs/operators';\nimport * as i2 from '@angular/cdk/bidi';\n\n// Animation values come from\n// TODO(mmalerba): Ideally find a way to import the values from MDC's code.\nconst panelAnimation = /*#__PURE__*/trigger('panelAnimation', [/*#__PURE__*/state('void, hidden', /*#__PURE__*/style({\n  opacity: 0,\n  transform: 'scaleY(0.8)'\n})), /*#__PURE__*/transition(':enter, hidden => visible', [/*#__PURE__*/group([/*#__PURE__*/animate('0.03s linear', /*#__PURE__*/style({\n  opacity: 1\n})), /*#__PURE__*/animate('0.12s cubic-bezier(0, 0, 0.2, 1)', /*#__PURE__*/style({\n  transform: 'scaleY(1)'\n}))])]), /*#__PURE__*/transition(':leave, visible => hidden', [/*#__PURE__*/animate('0.075s linear', /*#__PURE__*/style({\n  opacity: 0\n}))])]);\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/** Event object that is emitted when an autocomplete option is selected. */\nclass MatAutocompleteSelectedEvent {\n  constructor( /** Reference to the autocomplete panel that emitted the event. */\n  source, /** Option that was selected. */\n  option) {\n    this.source = source;\n    this.option = option;\n  }\n}\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-autocomplete-default-options', {\n  providedIn: 'root',\n  factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    autoActiveFirstOption: false,\n    autoSelectActiveOption: false,\n    hideSingleSelectionIndicator: false,\n    requireSelection: false\n  };\n}\n/** Autocomplete component. */\nlet MatAutocomplete = /*#__PURE__*/(() => {\n  class MatAutocomplete {\n    /** Whether the autocomplete panel is open. */\n    get isOpen() {\n      return this._isOpen && this.showPanel;\n    }\n    /** @docs-private Sets the theme color of the panel. */\n    _setColor(value) {\n      this._color = value;\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    set classList(value) {\n      this._classList = value;\n      this._elementRef.nativeElement.className = '';\n    }\n    /** Whether checkmark indicator for single-selection options is hidden. */\n    get hideSingleSelectionIndicator() {\n      return this._hideSingleSelectionIndicator;\n    }\n    set hideSingleSelectionIndicator(value) {\n      this._hideSingleSelectionIndicator = value;\n      this._syncParentProperties();\n    }\n    /** Syncs the parent state with the individual options. */\n    _syncParentProperties() {\n      if (this.options) {\n        for (const option of this.options) {\n          option._changeDetectorRef.markForCheck();\n        }\n      }\n    }\n    constructor(_changeDetectorRef, _elementRef, _defaults, platform) {\n      this._changeDetectorRef = _changeDetectorRef;\n      this._elementRef = _elementRef;\n      this._defaults = _defaults;\n      this._activeOptionChanges = Subscription.EMPTY;\n      /** Emits when the panel animation is done. Null if the panel doesn't animate. */\n      this._animationDone = new EventEmitter();\n      /** Whether the autocomplete panel should be visible, depending on option length. */\n      this.showPanel = false;\n      this._isOpen = false;\n      /** Function that maps an option's control value to its display value in the trigger. */\n      this.displayWith = null;\n      /** Event that is emitted whenever an option from the list is selected. */\n      this.optionSelected = new EventEmitter();\n      /** Event that is emitted when the autocomplete panel is opened. */\n      this.opened = new EventEmitter();\n      /** Event that is emitted when the autocomplete panel is closed. */\n      this.closed = new EventEmitter();\n      /** Emits whenever an option is activated. */\n      this.optionActivated = new EventEmitter();\n      /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n      this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n      // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n      // Safari using VoiceOver. We should occasionally check back to see whether the bug\n      // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n      // option altogether.\n      this.inertGroups = platform?.SAFARI || false;\n      this.autoActiveFirstOption = !!_defaults.autoActiveFirstOption;\n      this.autoSelectActiveOption = !!_defaults.autoSelectActiveOption;\n      this.requireSelection = !!_defaults.requireSelection;\n      this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n    }\n    ngAfterContentInit() {\n      this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap().skipPredicate(this._skipPredicate);\n      this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n        if (this.isOpen) {\n          this.optionActivated.emit({\n            source: this,\n            option: this.options.toArray()[index] || null\n          });\n        }\n      });\n      // Set the initial visibility state.\n      this._setVisibility();\n    }\n    ngOnDestroy() {\n      this._keyManager?.destroy();\n      this._activeOptionChanges.unsubscribe();\n      this._animationDone.complete();\n    }\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     */\n    _setScrollTop(scrollTop) {\n      if (this.panel) {\n        this.panel.nativeElement.scrollTop = scrollTop;\n      }\n    }\n    /** Returns the panel's scrollTop. */\n    _getScrollTop() {\n      return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /** Panel should hide itself when the option list is empty. */\n    _setVisibility() {\n      this.showPanel = !!this.options.length;\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Emits the `select` event. */\n    _emitSelectEvent(option) {\n      const event = new MatAutocompleteSelectedEvent(this, option);\n      this.optionSelected.emit(event);\n    }\n    /** Gets the aria-labelledby for the autocomplete panel. */\n    _getPanelAriaLabelledby(labelId) {\n      if (this.ariaLabel) {\n        return null;\n      }\n      const labelExpression = labelId ? labelId + ' ' : '';\n      return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n    }\n    // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n    // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n    // recommendation.\n    //\n    // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n    // makes a few exceptions for compound widgets.\n    //\n    // From [Developing a Keyboard Interface](\n    // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n    //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n    //   Listbox...\"\n    //\n    // The user can focus disabled options using the keyboard, but the user cannot click disabled\n    // options.\n    _skipPredicate() {\n      return false;\n    }\n    static #_ = this.ɵfac = function MatAutocomplete_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatAutocomplete)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS), i0.ɵɵdirectiveInject(i1.Platform));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatAutocomplete,\n      selectors: [[\"mat-autocomplete\"]],\n      contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MatOption, 5);\n          i0.ɵɵcontentQuery(dirIndex, MAT_OPTGROUP, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.options = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.optionGroups = _t);\n        }\n      },\n      viewQuery: function MatAutocomplete_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(TemplateRef, 7);\n          i0.ɵɵviewQuery(_c0, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panel = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-mdc-autocomplete\"],\n      inputs: {\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n        displayWith: \"displayWith\",\n        autoActiveFirstOption: [2, \"autoActiveFirstOption\", \"autoActiveFirstOption\", booleanAttribute],\n        autoSelectActiveOption: [2, \"autoSelectActiveOption\", \"autoSelectActiveOption\", booleanAttribute],\n        requireSelection: [2, \"requireSelection\", \"requireSelection\", booleanAttribute],\n        panelWidth: \"panelWidth\",\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute],\n        classList: [0, \"class\", \"classList\"],\n        hideSingleSelectionIndicator: [2, \"hideSingleSelectionIndicator\", \"hideSingleSelectionIndicator\", booleanAttribute]\n      },\n      outputs: {\n        optionSelected: \"optionSelected\",\n        opened: \"opened\",\n        closed: \"closed\",\n        optionActivated: \"optionActivated\"\n      },\n      exportAs: [\"matAutocomplete\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MAT_OPTION_PARENT_COMPONENT,\n        useExisting: MatAutocomplete\n      }]), i0.ɵɵInputTransformsFeature, i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      consts: [[\"panel\", \"\"], [\"role\", \"listbox\", 1, \"mat-mdc-autocomplete-panel\", \"mdc-menu-surface\", \"mdc-menu-surface--open\", 3, \"id\"]],\n      template: function MatAutocomplete_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵtemplate(0, MatAutocomplete_ng_template_0_Template, 3, 16, \"ng-template\");\n        }\n      },\n      styles: [\"div.mat-mdc-autocomplete-panel{width:100%;max-height:256px;visibility:hidden;transform-origin:center top;overflow:auto;padding:8px 0;box-sizing:border-box;position:static;border-radius:var(--mat-autocomplete-container-shape, var(--mat-app-corner-extra-small));box-shadow:var(--mat-autocomplete-container-elevation-shadow);background-color:var(--mat-autocomplete-background-color, var(--mat-app-surface-container))}.cdk-high-contrast-active div.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) div.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above div.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden;pointer-events:none}mat-autocomplete{display:none}\"],\n      encapsulation: 2,\n      data: {\n        animation: [panelAnimation]\n      },\n      changeDetection: 0\n    });\n  }\n  return MatAutocomplete;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\nlet MatAutocompleteOrigin = /*#__PURE__*/(() => {\n  class MatAutocompleteOrigin {\n    constructor( /** Reference to the element on which the directive is applied. */\n    elementRef) {\n      this.elementRef = elementRef;\n    }\n    static #_ = this.ɵfac = function MatAutocompleteOrigin_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatAutocompleteOrigin)(i0.ɵɵdirectiveInject(i0.ElementRef));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatAutocompleteOrigin,\n      selectors: [[\"\", \"matAutocompleteOrigin\", \"\"]],\n      exportAs: [\"matAutocompleteOrigin\"],\n      standalone: true\n    });\n  }\n  return MatAutocompleteOrigin;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(() => MatAutocompleteTrigger),\n  multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nfunction getMatAutocompleteMissingPanelError() {\n  return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' + 'Make sure that the id passed to the `matAutocomplete` is correct and that ' + \"you're attempting to open it after the ngAfterContentInit hook.\");\n}\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('mat-autocomplete-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const overlay = inject(Overlay);\n    return () => overlay.scrollStrategies.reposition();\n  }\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\nlet MatAutocompleteTrigger = /*#__PURE__*/(() => {\n  class MatAutocompleteTrigger {\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {\n      this._element = _element;\n      this._overlay = _overlay;\n      this._viewContainerRef = _viewContainerRef;\n      this._zone = _zone;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._dir = _dir;\n      this._formField = _formField;\n      this._document = _document;\n      this._viewportRuler = _viewportRuler;\n      this._defaults = _defaults;\n      this._componentDestroyed = false;\n      /** Whether or not the label state is being overridden. */\n      this._manuallyFloatingLabel = false;\n      /** Subscription to viewport size changes. */\n      this._viewportSubscription = Subscription.EMPTY;\n      /** Implements BreakpointObserver to be used to detect handset landscape */\n      this._breakpointObserver = inject(BreakpointObserver);\n      this._handsetLandscapeSubscription = Subscription.EMPTY;\n      /**\n       * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n       * closed autocomplete from being reopened if the user switches to another browser tab and then\n       * comes back.\n       */\n      this._canOpenOnNextFocus = true;\n      /** Stream of keyboard events that can close the panel. */\n      this._closeKeyEventStream = new Subject();\n      /**\n       * Event handler for when the window is blurred. Needs to be an\n       * arrow function in order to preserve the context.\n       */\n      this._windowBlurHandler = () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this._canOpenOnNextFocus = this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n      };\n      /** `View -> model callback called when value changes` */\n      this._onChange = () => {};\n      /** `View -> model callback called when autocomplete has been touched` */\n      this._onTouched = () => {};\n      /**\n       * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n       * will render the panel underneath the trigger if there is enough space for it to fit in\n       * the viewport, otherwise the panel will be shown above it. If the position is set to\n       * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n       * whether it fits completely in the viewport.\n       */\n      this.position = 'auto';\n      /**\n       * `autocomplete` attribute to be set on the input element.\n       * @docs-private\n       */\n      this.autocompleteAttribute = 'off';\n      this._initialized = new Subject();\n      this._injector = inject(Injector);\n      /** Class to apply to the panel when it's above the input. */\n      this._aboveClass = 'mat-mdc-autocomplete-panel-above';\n      this._overlayAttached = false;\n      /** Stream of changes to the selection state of the autocomplete options. */\n      this.optionSelections = defer(() => {\n        const options = this.autocomplete ? this.autocomplete.options : null;\n        if (options) {\n          return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));\n        }\n        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n        return this._initialized.pipe(switchMap(() => this.optionSelections));\n      });\n      /** Handles keyboard events coming from the overlay panel. */\n      this._handlePanelKeydown = event => {\n        // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n        // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n        if (event.keyCode === ESCAPE && !hasModifierKey(event) || event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey')) {\n          // If the user had typed something in before we autoselected an option, and they decided\n          // to cancel the selection, restore the input value to the one they had typed in.\n          if (this._pendingAutoselectedOption) {\n            this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n            this._pendingAutoselectedOption = null;\n          }\n          this._closeKeyEventStream.next();\n          this._resetActiveItem();\n          // We need to stop propagation, otherwise the event will eventually\n          // reach the input itself and cause the overlay to be reopened.\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      };\n      /**\n       * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n       * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n       * panel. Track the modal we have changed so we can undo the changes on destroy.\n       */\n      this._trackedModal = null;\n      this._scrollStrategy = scrollStrategy;\n    }\n    ngAfterViewInit() {\n      this._initialized.next();\n      this._initialized.complete();\n      const window = this._getWindow();\n      if (typeof window !== 'undefined') {\n        this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\n      }\n    }\n    ngOnChanges(changes) {\n      if (changes['position'] && this._positionStrategy) {\n        this._setStrategyPositions(this._positionStrategy);\n        if (this.panelOpen) {\n          this._overlayRef.updatePosition();\n        }\n      }\n    }\n    ngOnDestroy() {\n      const window = this._getWindow();\n      if (typeof window !== 'undefined') {\n        window.removeEventListener('blur', this._windowBlurHandler);\n      }\n      this._handsetLandscapeSubscription.unsubscribe();\n      this._viewportSubscription.unsubscribe();\n      this._componentDestroyed = true;\n      this._destroyPanel();\n      this._closeKeyEventStream.complete();\n      this._clearFromModal();\n    }\n    /** Whether or not the autocomplete panel is open. */\n    get panelOpen() {\n      return this._overlayAttached && this.autocomplete.showPanel;\n    }\n    /** Opens the autocomplete suggestion panel. */\n    openPanel() {\n      this._openPanelInternal();\n    }\n    /** Closes the autocomplete suggestion panel. */\n    closePanel() {\n      this._resetLabel();\n      if (!this._overlayAttached) {\n        return;\n      }\n      if (this.panelOpen) {\n        // Only emit if the panel was visible.\n        // `afterNextRender` always runs outside of the Angular zone, so all the subscriptions from\n        // `_subscribeToClosingActions()` are also outside of the Angular zone.\n        // We should manually run in Angular zone to update UI after panel closing.\n        this._zone.run(() => {\n          this.autocomplete.closed.emit();\n        });\n      }\n      // Only reset if this trigger is the latest one that opened the\n      // autocomplete since another may have taken it over.\n      if (this.autocomplete._latestOpeningTrigger === this) {\n        this.autocomplete._isOpen = false;\n        this.autocomplete._latestOpeningTrigger = null;\n      }\n      this._overlayAttached = false;\n      this._pendingAutoselectedOption = null;\n      if (this._overlayRef && this._overlayRef.hasAttached()) {\n        this._overlayRef.detach();\n        this._closingActionsSubscription.unsubscribe();\n      }\n      this._updatePanelState();\n      // Note that in some cases this can end up being called after the component is destroyed.\n      // Add a check to ensure that we don't try to run change detection on a destroyed view.\n      if (!this._componentDestroyed) {\n        // We need to trigger change detection manually, because\n        // `fromEvent` doesn't seem to do it at the proper time.\n        // This ensures that the label is reset when the\n        // user clicks outside.\n        this._changeDetectorRef.detectChanges();\n      }\n      // Remove aria-owns attribute when the autocomplete is no longer visible.\n      if (this._trackedModal) {\n        removeAriaReferencedId(this._trackedModal, 'aria-owns', this.autocomplete.id);\n      }\n    }\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition() {\n      if (this._overlayAttached) {\n        this._overlayRef.updatePosition();\n      }\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions() {\n      return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached)) : of()).pipe(\n      // Normalize the output so we return a consistent type.\n      map(event => event instanceof MatOptionSelectionChange ? event : null));\n    }\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption() {\n      if (this.autocomplete && this.autocomplete._keyManager) {\n        return this.autocomplete._keyManager.activeItem;\n      }\n      return null;\n    }\n    /** Stream of clicks outside of the autocomplete panel. */\n    _getOutsideClickStream() {\n      return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'auxclick'), fromEvent(this._document, 'touchend')).pipe(filter(event => {\n        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n        // fall back to check the first element in the path of the click event.\n        const clickTarget = _getEventTarget(event);\n        const formField = this._formField ? this._formField.getConnectedOverlayOrigin().nativeElement : null;\n        const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n        return this._overlayAttached && clickTarget !== this._element.nativeElement &&\n        // Normally focus moves inside `mousedown` so this condition will almost always be\n        // true. Its main purpose is to handle the case where the input is focused from an\n        // outside click which propagates up to the `body` listener within the same sequence\n        // and causes the panel to close immediately (see #3106).\n        this._document.activeElement !== this._element.nativeElement && (!formField || !formField.contains(clickTarget)) && (!customOrigin || !customOrigin.contains(clickTarget)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget);\n      }));\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n      Promise.resolve(null).then(() => this._assignOptionValue(value));\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n      this._element.nativeElement.disabled = isDisabled;\n    }\n    _handleKeydown(event) {\n      const keyCode = event.keyCode;\n      const hasModifier = hasModifierKey(event);\n      // Prevent the default action on all escape key presses. This is here primarily to bring IE\n      // in line with other browsers. By default, pressing escape on IE will cause it to revert\n      // the input value to the one that it had on focus, however it won't dispatch any events\n      // which means that the model value will be out of sync with the view.\n      if (keyCode === ESCAPE && !hasModifier) {\n        event.preventDefault();\n      }\n      this._valueOnLastKeydown = this._element.nativeElement.value;\n      if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n        this.activeOption._selectViaInteraction();\n        this._resetActiveItem();\n        event.preventDefault();\n      } else if (this.autocomplete) {\n        const prevActiveItem = this.autocomplete._keyManager.activeItem;\n        const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n        if (keyCode === TAB || isArrowKey && !hasModifier && this.panelOpen) {\n          this.autocomplete._keyManager.onKeydown(event);\n        } else if (isArrowKey && this._canOpen()) {\n          this._openPanelInternal(this._valueOnLastKeydown);\n        }\n        if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n          this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n          if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n            if (!this._pendingAutoselectedOption) {\n              this._valueBeforeAutoSelection = this._valueOnLastKeydown;\n            }\n            this._pendingAutoselectedOption = this.activeOption;\n            this._assignOptionValue(this.activeOption.value);\n          }\n        }\n      }\n    }\n    _handleInput(event) {\n      let target = event.target;\n      let value = target.value;\n      // Based on `NumberValueAccessor` from forms.\n      if (target.type === 'number') {\n        value = value == '' ? null : parseFloat(value);\n      }\n      // If the input has a placeholder, IE will fire the `input` event on page load,\n      // focus and blur, in addition to when the user actually changed the value. To\n      // filter out all of the extra events, we save the value on focus and between\n      // `input` events, and we check whether it changed.\n      // See: https://connect.microsoft.com/IE/feedback/details/885747/\n      if (this._previousValue !== value) {\n        this._previousValue = value;\n        this._pendingAutoselectedOption = null;\n        // If selection is required we don't write to the CVA while the user is typing.\n        // At the end of the selection either the user will have picked something\n        // or we'll reset the value back to null.\n        if (!this.autocomplete || !this.autocomplete.requireSelection) {\n          this._onChange(value);\n        }\n        if (!value) {\n          this._clearPreviousSelectedOption(null, false);\n        } else if (this.panelOpen && !this.autocomplete.requireSelection) {\n          // Note that we don't reset this when `requireSelection` is enabled,\n          // because the option will be reset when the panel is closed.\n          const selectedOption = this.autocomplete.options?.find(option => option.selected);\n          if (selectedOption) {\n            const display = this._getDisplayValue(selectedOption.value);\n            if (value !== display) {\n              selectedOption.deselect(false);\n            }\n          }\n        }\n        if (this._canOpen() && this._document.activeElement === event.target) {\n          // When the `input` event fires, the input's value will have already changed. This means\n          // that if we take the `this._element.nativeElement.value` directly, it'll be one keystroke\n          // behind. This can be a problem when the user selects a value, changes a character while\n          // the input still has focus and then clicks away (see #28432). To work around it, we\n          // capture the value in `keydown` so we can use it here.\n          const valueOnAttach = this._valueOnLastKeydown ?? this._element.nativeElement.value;\n          this._valueOnLastKeydown = null;\n          this._openPanelInternal(valueOnAttach);\n        }\n      }\n    }\n    _handleFocus() {\n      if (!this._canOpenOnNextFocus) {\n        this._canOpenOnNextFocus = true;\n      } else if (this._canOpen()) {\n        this._previousValue = this._element.nativeElement.value;\n        this._attachOverlay(this._previousValue);\n        this._floatLabel(true);\n      }\n    }\n    _handleClick() {\n      if (this._canOpen() && !this.panelOpen) {\n        this._openPanelInternal();\n      }\n    }\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @param shouldAnimate Whether the label should be animated when it is floated.\n     */\n    _floatLabel(shouldAnimate = false) {\n      if (this._formField && this._formField.floatLabel === 'auto') {\n        if (shouldAnimate) {\n          this._formField._animateAndLockLabel();\n        } else {\n          this._formField.floatLabel = 'always';\n        }\n        this._manuallyFloatingLabel = true;\n      }\n    }\n    /** If the label has been manually elevated, return it to its normal state. */\n    _resetLabel() {\n      if (this._manuallyFloatingLabel) {\n        if (this._formField) {\n          this._formField.floatLabel = 'auto';\n        }\n        this._manuallyFloatingLabel = false;\n      }\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    _subscribeToClosingActions() {\n      const initialRender = new Observable(subscriber => {\n        afterNextRender(() => {\n          subscriber.next();\n        }, {\n          injector: this._injector\n        });\n      });\n      const optionChanges = this.autocomplete.options.changes.pipe(tap(() => this._positionStrategy.reapplyLastPosition()),\n      // Defer emitting to the stream until the next tick, because changing\n      // bindings in here will cause \"changed after checked\" errors.\n      delay(0));\n      // When the options are initially rendered, and when the option list changes...\n      return merge(initialRender, optionChanges).pipe(\n      // create a new stream of panelClosingActions, replacing any previous streams\n      // that were created, and flatten it so our stream only emits closing events...\n      switchMap(() => this._zone.run(() => {\n        // `afterNextRender` always runs outside of the Angular zone, thus we have to re-enter\n        // the Angular zone. This will lead to change detection being called outside of the Angular\n        // zone and the `autocomplete.opened` will also emit outside of the Angular.\n        const wasOpen = this.panelOpen;\n        this._resetActiveItem();\n        this._updatePanelState();\n        this._changeDetectorRef.detectChanges();\n        if (this.panelOpen) {\n          this._overlayRef.updatePosition();\n        }\n        if (wasOpen !== this.panelOpen) {\n          // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n          // `closed` event, because we may not have emitted it. This can happen\n          // - if the users opens the panel and there are no options, but the\n          //   options come in slightly later or as a result of the value changing,\n          // - if the panel is closed after the user entered a string that did not match any\n          //   of the available options,\n          // - if a valid string is entered after an invalid one.\n          if (this.panelOpen) {\n            this._emitOpened();\n          } else {\n            this.autocomplete.closed.emit();\n          }\n        }\n        return this.panelClosingActions;\n      })),\n      // when the first closing event occurs...\n      take(1))\n      // set the value, close the panel, and complete.\n      .subscribe(event => this._setValueAndClose(event));\n    }\n    /**\n     * Emits the opened event once it's known that the panel will be shown and stores\n     * the state of the trigger right before the opening sequence was finished.\n     */\n    _emitOpened() {\n      this.autocomplete.opened.emit();\n    }\n    /** Destroys the autocomplete suggestion panel. */\n    _destroyPanel() {\n      if (this._overlayRef) {\n        this.closePanel();\n        this._overlayRef.dispose();\n        this._overlayRef = null;\n      }\n    }\n    /** Given a value, returns the string that should be shown within the input. */\n    _getDisplayValue(value) {\n      const autocomplete = this.autocomplete;\n      return autocomplete && autocomplete.displayWith ? autocomplete.displayWith(value) : value;\n    }\n    _assignOptionValue(value) {\n      const toDisplay = this._getDisplayValue(value);\n      if (value == null) {\n        this._clearPreviousSelectedOption(null, false);\n      }\n      // Simply falling back to an empty string if the display value is falsy does not work properly.\n      // The display value can also be the number zero and shouldn't fall back to an empty string.\n      this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n    }\n    _updateNativeInputValue(value) {\n      // If it's used within a `MatFormField`, we should set it through the property so it can go\n      // through change detection.\n      if (this._formField) {\n        this._formField._control.value = value;\n      } else {\n        this._element.nativeElement.value = value;\n      }\n      this._previousValue = value;\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    _setValueAndClose(event) {\n      const panel = this.autocomplete;\n      const toSelect = event ? event.source : this._pendingAutoselectedOption;\n      if (toSelect) {\n        this._clearPreviousSelectedOption(toSelect);\n        this._assignOptionValue(toSelect.value);\n        // TODO(crisbeto): this should wait until the animation is done, otherwise the value\n        // gets reset while the panel is still animating which looks glitchy. It'll likely break\n        // some tests to change it at this point.\n        this._onChange(toSelect.value);\n        panel._emitSelectEvent(toSelect);\n        this._element.nativeElement.focus();\n      } else if (panel.requireSelection && this._element.nativeElement.value !== this._valueOnAttach) {\n        this._clearPreviousSelectedOption(null);\n        this._assignOptionValue(null);\n        // Wait for the animation to finish before clearing the form control value, otherwise\n        // the options might change while the animation is running which looks glitchy.\n        if (panel._animationDone) {\n          panel._animationDone.pipe(take(1)).subscribe(() => this._onChange(null));\n        } else {\n          this._onChange(null);\n        }\n      }\n      this.closePanel();\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    _clearPreviousSelectedOption(skip, emitEvent) {\n      // Null checks are necessary here, because the autocomplete\n      // or its options may not have been assigned yet.\n      this.autocomplete?.options?.forEach(option => {\n        if (option !== skip && option.selected) {\n          option.deselect(emitEvent);\n        }\n      });\n    }\n    _openPanelInternal(valueOnAttach = this._element.nativeElement.value) {\n      this._attachOverlay(valueOnAttach);\n      this._floatLabel();\n      // Add aria-owns attribute when the autocomplete becomes visible.\n      if (this._trackedModal) {\n        const panelId = this.autocomplete.id;\n        addAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      }\n    }\n    _attachOverlay(valueOnAttach) {\n      if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatAutocompleteMissingPanelError();\n      }\n      let overlayRef = this._overlayRef;\n      if (!overlayRef) {\n        this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n          id: this._formField?.getLabelId()\n        });\n        overlayRef = this._overlay.create(this._getOverlayConfig());\n        this._overlayRef = overlayRef;\n        this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n          if (this.panelOpen && overlayRef) {\n            overlayRef.updateSize({\n              width: this._getPanelWidth()\n            });\n          }\n        });\n        // Subscribe to the breakpoint events stream to detect when screen is in\n        // handsetLandscape.\n        this._handsetLandscapeSubscription = this._breakpointObserver.observe(Breakpoints.HandsetLandscape).subscribe(result => {\n          const isHandsetLandscape = result.matches;\n          // Check if result.matches Breakpoints.HandsetLandscape. Apply HandsetLandscape\n          // settings to prevent overlay cutoff in that breakpoint. Fixes b/284148377\n          if (isHandsetLandscape) {\n            this._positionStrategy.withFlexibleDimensions(true).withGrowAfterOpen(true).withViewportMargin(8);\n          } else {\n            this._positionStrategy.withFlexibleDimensions(false).withGrowAfterOpen(false).withViewportMargin(0);\n          }\n        });\n      } else {\n        // Update the trigger, panel width and direction, in case anything has changed.\n        this._positionStrategy.setOrigin(this._getConnectedElement());\n        overlayRef.updateSize({\n          width: this._getPanelWidth()\n        });\n      }\n      if (overlayRef && !overlayRef.hasAttached()) {\n        overlayRef.attach(this._portal);\n        this._valueOnAttach = valueOnAttach;\n        this._valueOnLastKeydown = null;\n        this._closingActionsSubscription = this._subscribeToClosingActions();\n      }\n      const wasOpen = this.panelOpen;\n      this.autocomplete._isOpen = this._overlayAttached = true;\n      this.autocomplete._latestOpeningTrigger = this;\n      this.autocomplete._setColor(this._formField?.color);\n      this._updatePanelState();\n      this._applyModalPanelOwnership();\n      // We need to do an extra `panelOpen` check in here, because the\n      // autocomplete won't be shown if there are no options.\n      if (this.panelOpen && wasOpen !== this.panelOpen) {\n        this._emitOpened();\n      }\n    }\n    /** Updates the panel's visibility state and any trigger state tied to id. */\n    _updatePanelState() {\n      this.autocomplete._setVisibility();\n      // Note that here we subscribe and unsubscribe based on the panel's visiblity state,\n      // because the act of subscribing will prevent events from reaching other overlays and\n      // we don't want to block the events if there are no options.\n      if (this.panelOpen) {\n        const overlayRef = this._overlayRef;\n        if (!this._keydownSubscription) {\n          // Use the `keydownEvents` in order to take advantage of\n          // the overlay event targeting provided by the CDK overlay.\n          this._keydownSubscription = overlayRef.keydownEvents().subscribe(this._handlePanelKeydown);\n        }\n        if (!this._outsideClickSubscription) {\n          // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n          // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n          // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n          this._outsideClickSubscription = overlayRef.outsidePointerEvents().subscribe();\n        }\n      } else {\n        this._keydownSubscription?.unsubscribe();\n        this._outsideClickSubscription?.unsubscribe();\n        this._keydownSubscription = this._outsideClickSubscription = null;\n      }\n    }\n    _getOverlayConfig() {\n      return new OverlayConfig({\n        positionStrategy: this._getOverlayPosition(),\n        scrollStrategy: this._scrollStrategy(),\n        width: this._getPanelWidth(),\n        direction: this._dir ?? undefined,\n        panelClass: this._defaults?.overlayPanelClass\n      });\n    }\n    _getOverlayPosition() {\n      // Set default Overlay Position\n      const strategy = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(false).withPush(false);\n      this._setStrategyPositions(strategy);\n      this._positionStrategy = strategy;\n      return strategy;\n    }\n    /** Sets the positions on a position strategy based on the directive's input state. */\n    _setStrategyPositions(positionStrategy) {\n      // Note that we provide horizontal fallback positions, even though by default the dropdown\n      // width matches the input, because consumers can override the width. See #18854.\n      const belowPositions = [{\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n      }, {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n      }];\n      // The overlay edge connected to the trigger should have squared corners, while\n      // the opposite end has rounded corners. We apply a CSS class to swap the\n      // border-radius based on the overlay position.\n      const panelClass = this._aboveClass;\n      const abovePositions = [{\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom',\n        panelClass\n      }, {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom',\n        panelClass\n      }];\n      let positions;\n      if (this.position === 'above') {\n        positions = abovePositions;\n      } else if (this.position === 'below') {\n        positions = belowPositions;\n      } else {\n        positions = [...belowPositions, ...abovePositions];\n      }\n      positionStrategy.withPositions(positions);\n    }\n    _getConnectedElement() {\n      if (this.connectedTo) {\n        return this.connectedTo.elementRef;\n      }\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n    }\n    _getPanelWidth() {\n      return this.autocomplete.panelWidth || this._getHostWidth();\n    }\n    /** Returns the width of the input element, so the panel width can match it. */\n    _getHostWidth() {\n      return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n     * option.\n     *\n     * If the consumer opted-in to automatically activatating the first option, activate the first\n     * *enabled* option.\n     */\n    _resetActiveItem() {\n      const autocomplete = this.autocomplete;\n      if (autocomplete.autoActiveFirstOption) {\n        // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n        // because it activates the first option that passes the skip predicate, rather than the\n        // first *enabled* option.\n        let firstEnabledOptionIndex = -1;\n        for (let index = 0; index < autocomplete.options.length; index++) {\n          const option = autocomplete.options.get(index);\n          if (!option.disabled) {\n            firstEnabledOptionIndex = index;\n            break;\n          }\n        }\n        autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n      } else {\n        autocomplete._keyManager.setActiveItem(-1);\n      }\n    }\n    /** Determines whether the panel can be opened. */\n    _canOpen() {\n      const element = this._element.nativeElement;\n      return !element.readOnly && !element.disabled && !this.autocompleteDisabled;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n      return this._document?.defaultView || window;\n    }\n    /** Scrolls to a particular option in the list. */\n    _scrollToOption(index) {\n      // Given that we are not actually focusing active options, we must manually adjust scroll\n      // to reveal options below the fold. First, we find the offset of the option from the top\n      // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n      // the panel height + the option height, so the active option will be just visible at the\n      // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n      // will become the offset. If that offset is visible within the panel already, the scrollTop is\n      // not adjusted.\n      const autocomplete = this.autocomplete;\n      const labelCount = _countGroupLabelsBeforeOption(index, autocomplete.options, autocomplete.optionGroups);\n      if (index === 0 && labelCount === 1) {\n        // If we've got one group label before the option and we're at the top option,\n        // scroll the list to the top. This is better UX than scrolling the list to the\n        // top of the option, because it allows the user to read the top group's label.\n        autocomplete._setScrollTop(0);\n      } else if (autocomplete.panel) {\n        const option = autocomplete.options.toArray()[index];\n        if (option) {\n          const element = option._getHostElement();\n          const newScrollPosition = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);\n          autocomplete._setScrollTop(newScrollPosition);\n        }\n      }\n    }\n    /**\n     * If the autocomplete trigger is inside of an `aria-modal` element, connect\n     * that modal to the options panel with `aria-owns`.\n     *\n     * For some browser + screen reader combinations, when navigation is inside\n     * of an `aria-modal` element, the screen reader treats everything outside\n     * of that modal as hidden or invisible.\n     *\n     * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n     * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n     * from reaching the panel.\n     *\n     * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n     * the options panel. This effectively communicates to assistive technology that the\n     * options panel is part of the same interaction as the modal.\n     *\n     * At time of this writing, this issue is present in VoiceOver.\n     * See https://github.com/angular/components/issues/20694\n     */\n    _applyModalPanelOwnership() {\n      // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n      // the `LiveAnnouncer` and any other usages.\n      //\n      // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n      // section of the DOM we need to look through. This should cover all the cases we support, but\n      // the selector can be expanded if it turns out to be too narrow.\n      const modal = this._element.nativeElement.closest('body > .cdk-overlay-container [aria-modal=\"true\"]');\n      if (!modal) {\n        // Most commonly, the autocomplete trigger is not inside a modal.\n        return;\n      }\n      const panelId = this.autocomplete.id;\n      if (this._trackedModal) {\n        removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      }\n      addAriaReferencedId(modal, 'aria-owns', panelId);\n      this._trackedModal = modal;\n    }\n    /** Clears the references to the listbox overlay element from the modal it was added to. */\n    _clearFromModal() {\n      if (this._trackedModal) {\n        const panelId = this.autocomplete.id;\n        removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n        this._trackedModal = null;\n      }\n    }\n    static #_ = this.ɵfac = function MatAutocompleteTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatAutocompleteTrigger)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.Overlay), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY), i0.ɵɵdirectiveInject(i2.Directionality, 8), i0.ɵɵdirectiveInject(MAT_FORM_FIELD, 9), i0.ɵɵdirectiveInject(DOCUMENT, 8), i0.ɵɵdirectiveInject(i3.ViewportRuler), i0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, 8));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatAutocompleteTrigger,\n      selectors: [[\"input\", \"matAutocomplete\", \"\"], [\"textarea\", \"matAutocomplete\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-autocomplete-trigger\"],\n      hostVars: 7,\n      hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focusin\", function MatAutocompleteTrigger_focusin_HostBindingHandler() {\n            return ctx._handleFocus();\n          })(\"blur\", function MatAutocompleteTrigger_blur_HostBindingHandler() {\n            return ctx._onTouched();\n          })(\"input\", function MatAutocompleteTrigger_input_HostBindingHandler($event) {\n            return ctx._handleInput($event);\n          })(\"keydown\", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) {\n            return ctx._handleKeydown($event);\n          })(\"click\", function MatAutocompleteTrigger_click_HostBindingHandler() {\n            return ctx._handleClick();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"autocomplete\", ctx.autocompleteAttribute)(\"role\", ctx.autocompleteDisabled ? null : \"combobox\")(\"aria-autocomplete\", ctx.autocompleteDisabled ? null : \"list\")(\"aria-activedescendant\", ctx.panelOpen && ctx.activeOption ? ctx.activeOption.id : null)(\"aria-expanded\", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())(\"aria-controls\", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id)(\"aria-haspopup\", ctx.autocompleteDisabled ? null : \"listbox\");\n        }\n      },\n      inputs: {\n        autocomplete: [0, \"matAutocomplete\", \"autocomplete\"],\n        position: [0, \"matAutocompletePosition\", \"position\"],\n        connectedTo: [0, \"matAutocompleteConnectedTo\", \"connectedTo\"],\n        autocompleteAttribute: [0, \"autocomplete\", \"autocompleteAttribute\"],\n        autocompleteDisabled: [2, \"matAutocompleteDisabled\", \"autocompleteDisabled\", booleanAttribute]\n      },\n      exportAs: [\"matAutocompleteTrigger\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]), i0.ɵɵInputTransformsFeature, i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return MatAutocompleteTrigger;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatAutocompleteModule = /*#__PURE__*/(() => {\n  class MatAutocompleteModule {\n    static #_ = this.ɵfac = function MatAutocompleteModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatAutocompleteModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatAutocompleteModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n      imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule, CdkScrollableModule, MatOptionModule, MatCommonModule]\n    });\n  }\n  return MatAutocompleteModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, getMatAutocompleteMissingPanelError };","map":{"version":3,"names":["i0","InjectionToken","EventEmitter","booleanAttribute","TemplateRef","Component","ViewEncapsulation","ChangeDetectionStrategy","Inject","ViewChild","ContentChildren","Input","Output","Directive","forwardRef","inject","Injector","afterNextRender","Optional","Host","NgModule","MAT_OPTION_PARENT_COMPONENT","MatOption","MAT_OPTGROUP","MatOptionSelectionChange","_countGroupLabelsBeforeOption","_getOptionScrollPosition","MatOptionModule","MatCommonModule","_c0","_c1","MatAutocomplete_ng_template_0_Template","rf","ctx","_r1","ɵɵgetCurrentView","ɵɵelementStart","ɵɵlistener","MatAutocomplete_ng_template_0_Template_div_animation_panelAnimation_done_0_listener","$event","ɵɵrestoreView","ctx_r1","ɵɵnextContext","ɵɵresetView","_animationDone","next","ɵɵprojection","ɵɵelementEnd","formFieldId_r3","id","ɵɵclassMap","_classList","ɵɵclassProp","showPanel","_color","ɵɵproperty","isOpen","ɵɵattribute","ariaLabel","_getPanelAriaLabelledby","MatOptgroup","DOCUMENT","CommonModule","i3","CdkScrollableModule","i1$1","Overlay","OverlayConfig","OverlayModule","ActiveDescendantKeyManager","removeAriaReferencedId","addAriaReferencedId","i1","_getEventTarget","trigger","state","style","transition","group","animate","Subscription","Subject","defer","merge","of","fromEvent","Observable","ESCAPE","hasModifierKey","UP_ARROW","ENTER","DOWN_ARROW","TAB","BreakpointObserver","Breakpoints","TemplatePortal","NG_VALUE_ACCESSOR","i4","MAT_FORM_FIELD","startWith","switchMap","filter","map","tap","delay","take","i2","panelAnimation","opacity","transform","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","constructor","source","option","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","providedIn","factory","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","autoSelectActiveOption","hideSingleSelectionIndicator","requireSelection","MatAutocomplete","_isOpen","_setColor","value","_changeDetectorRef","markForCheck","classList","_elementRef","nativeElement","className","_hideSingleSelectionIndicator","_syncParentProperties","options","_defaults","platform","_activeOptionChanges","EMPTY","displayWith","optionSelected","opened","closed","optionActivated","inertGroups","SAFARI","ngAfterContentInit","_keyManager","withWrap","skipPredicate","_skipPredicate","change","subscribe","index","emit","toArray","_setVisibility","ngOnDestroy","destroy","unsubscribe","complete","_setScrollTop","scrollTop","panel","_getScrollTop","length","_emitSelectEvent","event","labelId","labelExpression","ariaLabelledby","_","ɵfac","MatAutocomplete_Factory","__ngFactoryType__","ɵɵdirectiveInject","ChangeDetectorRef","ElementRef","Platform","_2","ɵcmp","ɵɵdefineComponent","type","selectors","contentQueries","MatAutocomplete_ContentQueries","dirIndex","ɵɵcontentQuery","_t","ɵɵqueryRefresh","ɵɵloadQuery","optionGroups","viewQuery","MatAutocomplete_Query","ɵɵviewQuery","template","first","hostAttrs","inputs","panelWidth","disableRipple","outputs","exportAs","standalone","features","ɵɵProvidersFeature","provide","useExisting","ɵɵInputTransformsFeature","ɵɵStandaloneFeature","ngContentSelectors","decls","vars","consts","MatAutocomplete_Template","ɵɵprojectionDef","ɵɵtemplate","styles","encapsulation","data","animation","changeDetection","ngDevMode","MatAutocompleteOrigin","elementRef","MatAutocompleteOrigin_Factory","ɵdir","ɵɵdefineDirective","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","overlay","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","useFactory","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_componentDestroyed","_manuallyFloatingLabel","_viewportSubscription","_breakpointObserver","_handsetLandscapeSubscription","_canOpenOnNextFocus","_closeKeyEventStream","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_initialized","_injector","_aboveClass","_overlayAttached","optionSelections","autocomplete","changes","pipe","onSelectionChange","_handlePanelKeydown","keyCode","_pendingAutoselectedOption","_updateNativeInputValue","_valueBeforeAutoSelection","_resetActiveItem","stopPropagation","preventDefault","_trackedModal","_scrollStrategy","ngAfterViewInit","window","_getWindow","runOutsideAngular","addEventListener","ngOnChanges","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","removeEventListener","_destroyPanel","_clearFromModal","openPanel","_openPanelInternal","closePanel","_resetLabel","run","_latestOpeningTrigger","hasAttached","detach","_closingActionsSubscription","_updatePanelState","detectChanges","panelClosingActions","tabOut","_getOutsideClickStream","detachments","activeOption","activeItem","clickTarget","formField","getConnectedOverlayOrigin","customOrigin","connectedTo","contains","overlayElement","writeValue","Promise","resolve","then","_assignOptionValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","_handleKeydown","hasModifier","_valueOnLastKeydown","_selectViaInteraction","prevActiveItem","isArrowKey","onKeydown","_canOpen","_scrollToOption","activeItemIndex","_handleInput","target","parseFloat","_previousValue","_clearPreviousSelectedOption","selectedOption","find","selected","display","_getDisplayValue","deselect","valueOnAttach","_handleFocus","_attachOverlay","_floatLabel","_handleClick","shouldAnimate","floatLabel","_animateAndLockLabel","_subscribeToClosingActions","initialRender","subscriber","injector","optionChanges","reapplyLastPosition","wasOpen","_emitOpened","_setValueAndClose","dispose","toDisplay","_control","toSelect","focus","_valueOnAttach","skip","emitEvent","forEach","panelId","overlayRef","_portal","getLabelId","create","_getOverlayConfig","updateSize","width","_getPanelWidth","observe","HandsetLandscape","result","isHandsetLandscape","matches","withFlexibleDimensions","withGrowAfterOpen","withViewportMargin","setOrigin","_getConnectedElement","attach","color","_applyModalPanelOwnership","_keydownSubscription","keydownEvents","_outsideClickSubscription","outsidePointerEvents","positionStrategy","_getOverlayPosition","direction","undefined","panelClass","overlayPanelClass","strategy","flexibleConnectedTo","withPush","belowPositions","originX","originY","overlayX","overlayY","abovePositions","positions","withPositions","_getHostWidth","getBoundingClientRect","firstEnabledOptionIndex","get","setActiveItem","element","readOnly","autocompleteDisabled","defaultView","labelCount","_getHostElement","newScrollPosition","offsetTop","offsetHeight","modal","closest","MatAutocompleteTrigger_Factory","ViewContainerRef","NgZone","Directionality","ViewportRuler","hostVars","hostBindings","MatAutocompleteTrigger_HostBindings","MatAutocompleteTrigger_focusin_HostBindingHandler","MatAutocompleteTrigger_blur_HostBindingHandler","MatAutocompleteTrigger_input_HostBindingHandler","MatAutocompleteTrigger_keydown_HostBindingHandler","MatAutocompleteTrigger_click_HostBindingHandler","toString","ɵɵNgOnChangesFeature","MatAutocompleteModule","MatAutocompleteModule_Factory","ɵmod","ɵɵdefineNgModule","_3","ɵinj","ɵɵdefineInjector","providers","imports"],"sources":["/Users/kyriakoskoutsos/university-courses-ui-1/node_modules/@angular/material/fesm2022/autocomplete.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, booleanAttribute, TemplateRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Inject, ViewChild, ContentChildren, Input, Output, Directive, forwardRef, inject, Injector, afterNextRender, Optional, Host, NgModule } from '@angular/core';\nimport { MAT_OPTION_PARENT_COMPONENT, MatOption, MAT_OPTGROUP, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\nexport { MatOptgroup, MatOption } from '@angular/material/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i3 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { ActiveDescendantKeyManager, removeAriaReferencedId, addAriaReferencedId } from '@angular/cdk/a11y';\nimport * as i1 from '@angular/cdk/platform';\nimport { _getEventTarget } from '@angular/cdk/platform';\nimport { trigger, state, style, transition, group, animate } from '@angular/animations';\nimport { Subscription, Subject, defer, merge, of, fromEvent, Observable } from 'rxjs';\nimport { ESCAPE, hasModifierKey, UP_ARROW, ENTER, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\nimport { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport * as i4 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD } from '@angular/material/form-field';\nimport { startWith, switchMap, filter, map, tap, delay, take } from 'rxjs/operators';\nimport * as i2 from '@angular/cdk/bidi';\n\n// Animation values come from\n// TODO(mmalerba): Ideally find a way to import the values from MDC's code.\nconst panelAnimation = trigger('panelAnimation', [\n    state('void, hidden', style({\n        opacity: 0,\n        transform: 'scaleY(0.8)',\n    })),\n    transition(':enter, hidden => visible', [\n        group([\n            animate('0.03s linear', style({ opacity: 1 })),\n            animate('0.12s cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scaleY(1)' })),\n        ]),\n    ]),\n    transition(':leave, visible => hidden', [animate('0.075s linear', style({ opacity: 0 }))]),\n]);\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/** Event object that is emitted when an autocomplete option is selected. */\nclass MatAutocompleteSelectedEvent {\n    constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    source, \n    /** Option that was selected. */\n    option) {\n        this.source = source;\n        this.option = option;\n    }\n}\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\n    providedIn: 'root',\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        autoActiveFirstOption: false,\n        autoSelectActiveOption: false,\n        hideSingleSelectionIndicator: false,\n        requireSelection: false,\n    };\n}\n/** Autocomplete component. */\nclass MatAutocomplete {\n    /** Whether the autocomplete panel is open. */\n    get isOpen() {\n        return this._isOpen && this.showPanel;\n    }\n    /** @docs-private Sets the theme color of the panel. */\n    _setColor(value) {\n        this._color = value;\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    set classList(value) {\n        this._classList = value;\n        this._elementRef.nativeElement.className = '';\n    }\n    /** Whether checkmark indicator for single-selection options is hidden. */\n    get hideSingleSelectionIndicator() {\n        return this._hideSingleSelectionIndicator;\n    }\n    set hideSingleSelectionIndicator(value) {\n        this._hideSingleSelectionIndicator = value;\n        this._syncParentProperties();\n    }\n    /** Syncs the parent state with the individual options. */\n    _syncParentProperties() {\n        if (this.options) {\n            for (const option of this.options) {\n                option._changeDetectorRef.markForCheck();\n            }\n        }\n    }\n    constructor(_changeDetectorRef, _elementRef, _defaults, platform) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._elementRef = _elementRef;\n        this._defaults = _defaults;\n        this._activeOptionChanges = Subscription.EMPTY;\n        /** Emits when the panel animation is done. Null if the panel doesn't animate. */\n        this._animationDone = new EventEmitter();\n        /** Whether the autocomplete panel should be visible, depending on option length. */\n        this.showPanel = false;\n        this._isOpen = false;\n        /** Function that maps an option's control value to its display value in the trigger. */\n        this.displayWith = null;\n        /** Event that is emitted whenever an option from the list is selected. */\n        this.optionSelected = new EventEmitter();\n        /** Event that is emitted when the autocomplete panel is opened. */\n        this.opened = new EventEmitter();\n        /** Event that is emitted when the autocomplete panel is closed. */\n        this.closed = new EventEmitter();\n        /** Emits whenever an option is activated. */\n        this.optionActivated = new EventEmitter();\n        /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n        // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n        // Safari using VoiceOver. We should occasionally check back to see whether the bug\n        // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n        // option altogether.\n        this.inertGroups = platform?.SAFARI || false;\n        this.autoActiveFirstOption = !!_defaults.autoActiveFirstOption;\n        this.autoSelectActiveOption = !!_defaults.autoSelectActiveOption;\n        this.requireSelection = !!_defaults.requireSelection;\n        this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n    }\n    ngAfterContentInit() {\n        this._keyManager = new ActiveDescendantKeyManager(this.options)\n            .withWrap()\n            .skipPredicate(this._skipPredicate);\n        this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n            if (this.isOpen) {\n                this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\n            }\n        });\n        // Set the initial visibility state.\n        this._setVisibility();\n    }\n    ngOnDestroy() {\n        this._keyManager?.destroy();\n        this._activeOptionChanges.unsubscribe();\n        this._animationDone.complete();\n    }\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     */\n    _setScrollTop(scrollTop) {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n    /** Returns the panel's scrollTop. */\n    _getScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /** Panel should hide itself when the option list is empty. */\n    _setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Emits the `select` event. */\n    _emitSelectEvent(option) {\n        const event = new MatAutocompleteSelectedEvent(this, option);\n        this.optionSelected.emit(event);\n    }\n    /** Gets the aria-labelledby for the autocomplete panel. */\n    _getPanelAriaLabelledby(labelId) {\n        if (this.ariaLabel) {\n            return null;\n        }\n        const labelExpression = labelId ? labelId + ' ' : '';\n        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n    }\n    // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n    // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n    // recommendation.\n    //\n    // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n    // makes a few exceptions for compound widgets.\n    //\n    // From [Developing a Keyboard Interface](\n    // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n    //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n    //   Listbox...\"\n    //\n    // The user can focus disabled options using the keyboard, but the user cannot click disabled\n    // options.\n    _skipPredicate() {\n        return false;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocomplete, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"16.1.0\", version: \"18.2.0-next.2\", type: MatAutocomplete, isStandalone: true, selector: \"mat-autocomplete\", inputs: { ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], displayWith: \"displayWith\", autoActiveFirstOption: [\"autoActiveFirstOption\", \"autoActiveFirstOption\", booleanAttribute], autoSelectActiveOption: [\"autoSelectActiveOption\", \"autoSelectActiveOption\", booleanAttribute], requireSelection: [\"requireSelection\", \"requireSelection\", booleanAttribute], panelWidth: \"panelWidth\", disableRipple: [\"disableRipple\", \"disableRipple\", booleanAttribute], classList: [\"class\", \"classList\"], hideSingleSelectionIndicator: [\"hideSingleSelectionIndicator\", \"hideSingleSelectionIndicator\", booleanAttribute] }, outputs: { optionSelected: \"optionSelected\", opened: \"opened\", closed: \"closed\", optionActivated: \"optionActivated\" }, host: { classAttribute: \"mat-mdc-autocomplete\" }, providers: [{ provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }], queries: [{ propertyName: \"options\", predicate: MatOption, descendants: true }, { propertyName: \"optionGroups\", predicate: MAT_OPTGROUP, descendants: true }], viewQueries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true, static: true }, { propertyName: \"panel\", first: true, predicate: [\"panel\"], descendants: true }], exportAs: [\"matAutocomplete\"], ngImport: i0, template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div\\n    class=\\\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\\\"\\n    role=\\\"listbox\\\"\\n    [id]=\\\"id\\\"\\n    [class]=\\\"_classList\\\"\\n    [class.mat-mdc-autocomplete-visible]=\\\"showPanel\\\"\\n    [class.mat-mdc-autocomplete-hidden]=\\\"!showPanel\\\"\\n    [class.mat-primary]=\\\"_color === 'primary'\\\"\\n    [class.mat-accent]=\\\"_color === 'accent'\\\"\\n    [class.mat-warn]=\\\"_color === 'warn'\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n    [@panelAnimation]=\\\"isOpen ? 'visible' : 'hidden'\\\"\\n    (@panelAnimation.done)=\\\"_animationDone.next($event)\\\"\\n    #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\", styles: [\"div.mat-mdc-autocomplete-panel{width:100%;max-height:256px;visibility:hidden;transform-origin:center top;overflow:auto;padding:8px 0;box-sizing:border-box;position:static;border-radius:var(--mat-autocomplete-container-shape, var(--mat-app-corner-extra-small));box-shadow:var(--mat-autocomplete-container-elevation-shadow);background-color:var(--mat-autocomplete-background-color, var(--mat-app-surface-container))}.cdk-high-contrast-active div.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) div.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above div.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden;pointer-events:none}mat-autocomplete{display:none}\"], animations: [panelAnimation], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocomplete, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-autocomplete', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'matAutocomplete', host: {\n                        'class': 'mat-mdc-autocomplete',\n                    }, providers: [{ provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }], animations: [panelAnimation], standalone: true, template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div\\n    class=\\\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\\\"\\n    role=\\\"listbox\\\"\\n    [id]=\\\"id\\\"\\n    [class]=\\\"_classList\\\"\\n    [class.mat-mdc-autocomplete-visible]=\\\"showPanel\\\"\\n    [class.mat-mdc-autocomplete-hidden]=\\\"!showPanel\\\"\\n    [class.mat-primary]=\\\"_color === 'primary'\\\"\\n    [class.mat-accent]=\\\"_color === 'accent'\\\"\\n    [class.mat-warn]=\\\"_color === 'warn'\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n    [@panelAnimation]=\\\"isOpen ? 'visible' : 'hidden'\\\"\\n    (@panelAnimation.done)=\\\"_animationDone.next($event)\\\"\\n    #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\", styles: [\"div.mat-mdc-autocomplete-panel{width:100%;max-height:256px;visibility:hidden;transform-origin:center top;overflow:auto;padding:8px 0;box-sizing:border-box;position:static;border-radius:var(--mat-autocomplete-container-shape, var(--mat-app-corner-extra-small));box-shadow:var(--mat-autocomplete-container-elevation-shadow);background-color:var(--mat-autocomplete-background-color, var(--mat-app-surface-container))}.cdk-high-contrast-active div.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) div.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above div.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden;pointer-events:none}mat-autocomplete{display:none}\"] }]\n        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\n                }] }, { type: i1.Platform }], propDecorators: { template: [{\n                type: ViewChild,\n                args: [TemplateRef, { static: true }]\n            }], panel: [{\n                type: ViewChild,\n                args: ['panel']\n            }], options: [{\n                type: ContentChildren,\n                args: [MatOption, { descendants: true }]\n            }], optionGroups: [{\n                type: ContentChildren,\n                args: [MAT_OPTGROUP, { descendants: true }]\n            }], ariaLabel: [{\n                type: Input,\n                args: ['aria-label']\n            }], ariaLabelledby: [{\n                type: Input,\n                args: ['aria-labelledby']\n            }], displayWith: [{\n                type: Input\n            }], autoActiveFirstOption: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], autoSelectActiveOption: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], requireSelection: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], panelWidth: [{\n                type: Input\n            }], disableRipple: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], optionSelected: [{\n                type: Output\n            }], opened: [{\n                type: Output\n            }], closed: [{\n                type: Output\n            }], optionActivated: [{\n                type: Output\n            }], classList: [{\n                type: Input,\n                args: ['class']\n            }], hideSingleSelectionIndicator: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }] } });\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\nclass MatAutocompleteOrigin {\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef) {\n        this.elementRef = elementRef;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteOrigin, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", type: MatAutocompleteOrigin, isStandalone: true, selector: \"[matAutocompleteOrigin]\", exportAs: [\"matAutocompleteOrigin\"], ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteOrigin, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matAutocompleteOrigin]',\n                    exportAs: 'matAutocompleteOrigin',\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }] });\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => MatAutocompleteTrigger),\n    multi: true,\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nfunction getMatAutocompleteMissingPanelError() {\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n        \"you're attempting to open it after the ngAfterContentInit hook.\");\n}\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy', {\n    providedIn: 'root',\n    factory: () => {\n        const overlay = inject(Overlay);\n        return () => overlay.scrollStrategies.reposition();\n    },\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\nclass MatAutocompleteTrigger {\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {\n        this._element = _element;\n        this._overlay = _overlay;\n        this._viewContainerRef = _viewContainerRef;\n        this._zone = _zone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._formField = _formField;\n        this._document = _document;\n        this._viewportRuler = _viewportRuler;\n        this._defaults = _defaults;\n        this._componentDestroyed = false;\n        /** Whether or not the label state is being overridden. */\n        this._manuallyFloatingLabel = false;\n        /** Subscription to viewport size changes. */\n        this._viewportSubscription = Subscription.EMPTY;\n        /** Implements BreakpointObserver to be used to detect handset landscape */\n        this._breakpointObserver = inject(BreakpointObserver);\n        this._handsetLandscapeSubscription = Subscription.EMPTY;\n        /**\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\n         * comes back.\n         */\n        this._canOpenOnNextFocus = true;\n        /** Stream of keyboard events that can close the panel. */\n        this._closeKeyEventStream = new Subject();\n        /**\n         * Event handler for when the window is blurred. Needs to be an\n         * arrow function in order to preserve the context.\n         */\n        this._windowBlurHandler = () => {\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\n            // refocused when they come back. In this case we want to skip the first focus event, if the\n            // pane was closed, in order to avoid reopening it unintentionally.\n            this._canOpenOnNextFocus =\n                this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n        };\n        /** `View -> model callback called when value changes` */\n        this._onChange = () => { };\n        /** `View -> model callback called when autocomplete has been touched` */\n        this._onTouched = () => { };\n        /**\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n         * will render the panel underneath the trigger if there is enough space for it to fit in\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n         * whether it fits completely in the viewport.\n         */\n        this.position = 'auto';\n        /**\n         * `autocomplete` attribute to be set on the input element.\n         * @docs-private\n         */\n        this.autocompleteAttribute = 'off';\n        this._initialized = new Subject();\n        this._injector = inject(Injector);\n        /** Class to apply to the panel when it's above the input. */\n        this._aboveClass = 'mat-mdc-autocomplete-panel-above';\n        this._overlayAttached = false;\n        /** Stream of changes to the selection state of the autocomplete options. */\n        this.optionSelections = defer(() => {\n            const options = this.autocomplete ? this.autocomplete.options : null;\n            if (options) {\n                return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));\n            }\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n            // Return a stream that we'll replace with the real one once everything is in place.\n            return this._initialized.pipe(switchMap(() => this.optionSelections));\n        });\n        /** Handles keyboard events coming from the overlay panel. */\n        this._handlePanelKeydown = (event) => {\n            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n            if ((event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n                (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))) {\n                // If the user had typed something in before we autoselected an option, and they decided\n                // to cancel the selection, restore the input value to the one they had typed in.\n                if (this._pendingAutoselectedOption) {\n                    this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n                    this._pendingAutoselectedOption = null;\n                }\n                this._closeKeyEventStream.next();\n                this._resetActiveItem();\n                // We need to stop propagation, otherwise the event will eventually\n                // reach the input itself and cause the overlay to be reopened.\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        };\n        /**\n         * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n         * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n         * panel. Track the modal we have changed so we can undo the changes on destroy.\n         */\n        this._trackedModal = null;\n        this._scrollStrategy = scrollStrategy;\n    }\n    ngAfterViewInit() {\n        this._initialized.next();\n        this._initialized.complete();\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['position'] && this._positionStrategy) {\n            this._setStrategyPositions(this._positionStrategy);\n            if (this.panelOpen) {\n                this._overlayRef.updatePosition();\n            }\n        }\n    }\n    ngOnDestroy() {\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this._windowBlurHandler);\n        }\n        this._handsetLandscapeSubscription.unsubscribe();\n        this._viewportSubscription.unsubscribe();\n        this._componentDestroyed = true;\n        this._destroyPanel();\n        this._closeKeyEventStream.complete();\n        this._clearFromModal();\n    }\n    /** Whether or not the autocomplete panel is open. */\n    get panelOpen() {\n        return this._overlayAttached && this.autocomplete.showPanel;\n    }\n    /** Opens the autocomplete suggestion panel. */\n    openPanel() {\n        this._openPanelInternal();\n    }\n    /** Closes the autocomplete suggestion panel. */\n    closePanel() {\n        this._resetLabel();\n        if (!this._overlayAttached) {\n            return;\n        }\n        if (this.panelOpen) {\n            // Only emit if the panel was visible.\n            // `afterNextRender` always runs outside of the Angular zone, so all the subscriptions from\n            // `_subscribeToClosingActions()` are also outside of the Angular zone.\n            // We should manually run in Angular zone to update UI after panel closing.\n            this._zone.run(() => {\n                this.autocomplete.closed.emit();\n            });\n        }\n        // Only reset if this trigger is the latest one that opened the\n        // autocomplete since another may have taken it over.\n        if (this.autocomplete._latestOpeningTrigger === this) {\n            this.autocomplete._isOpen = false;\n            this.autocomplete._latestOpeningTrigger = null;\n        }\n        this._overlayAttached = false;\n        this._pendingAutoselectedOption = null;\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\n            this._overlayRef.detach();\n            this._closingActionsSubscription.unsubscribe();\n        }\n        this._updatePanelState();\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this._componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this._changeDetectorRef.detectChanges();\n        }\n        // Remove aria-owns attribute when the autocomplete is no longer visible.\n        if (this._trackedModal) {\n            removeAriaReferencedId(this._trackedModal, 'aria-owns', this.autocomplete.id);\n        }\n    }\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition() {\n        if (this._overlayAttached) {\n            this._overlayRef.updatePosition();\n        }\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions() {\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef\n            ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached))\n            : of()).pipe(\n        // Normalize the output so we return a consistent type.\n        map(event => (event instanceof MatOptionSelectionChange ? event : null)));\n    }\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption() {\n        if (this.autocomplete && this.autocomplete._keyManager) {\n            return this.autocomplete._keyManager.activeItem;\n        }\n        return null;\n    }\n    /** Stream of clicks outside of the autocomplete panel. */\n    _getOutsideClickStream() {\n        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'auxclick'), fromEvent(this._document, 'touchend')).pipe(filter(event => {\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n            // fall back to check the first element in the path of the click event.\n            const clickTarget = _getEventTarget(event);\n            const formField = this._formField\n                ? this._formField.getConnectedOverlayOrigin().nativeElement\n                : null;\n            const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n            return (this._overlayAttached &&\n                clickTarget !== this._element.nativeElement &&\n                // Normally focus moves inside `mousedown` so this condition will almost always be\n                // true. Its main purpose is to handle the case where the input is focused from an\n                // outside click which propagates up to the `body` listener within the same sequence\n                // and causes the panel to close immediately (see #3106).\n                this._document.activeElement !== this._element.nativeElement &&\n                (!formField || !formField.contains(clickTarget)) &&\n                (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                !!this._overlayRef &&\n                !this._overlayRef.overlayElement.contains(clickTarget));\n        }));\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n        Promise.resolve(null).then(() => this._assignOptionValue(value));\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n        this._element.nativeElement.disabled = isDisabled;\n    }\n    _handleKeydown(event) {\n        const keyCode = event.keyCode;\n        const hasModifier = hasModifierKey(event);\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE && !hasModifier) {\n            event.preventDefault();\n        }\n        this._valueOnLastKeydown = this._element.nativeElement.value;\n        if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n            this.activeOption._selectViaInteraction();\n            this._resetActiveItem();\n            event.preventDefault();\n        }\n        else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete._keyManager.activeItem;\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n            if (keyCode === TAB || (isArrowKey && !hasModifier && this.panelOpen)) {\n                this.autocomplete._keyManager.onKeydown(event);\n            }\n            else if (isArrowKey && this._canOpen()) {\n                this._openPanelInternal(this._valueOnLastKeydown);\n            }\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n                if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n                    if (!this._pendingAutoselectedOption) {\n                        this._valueBeforeAutoSelection = this._valueOnLastKeydown;\n                    }\n                    this._pendingAutoselectedOption = this.activeOption;\n                    this._assignOptionValue(this.activeOption.value);\n                }\n            }\n        }\n    }\n    _handleInput(event) {\n        let target = event.target;\n        let value = target.value;\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value == '' ? null : parseFloat(value);\n        }\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this._previousValue !== value) {\n            this._previousValue = value;\n            this._pendingAutoselectedOption = null;\n            // If selection is required we don't write to the CVA while the user is typing.\n            // At the end of the selection either the user will have picked something\n            // or we'll reset the value back to null.\n            if (!this.autocomplete || !this.autocomplete.requireSelection) {\n                this._onChange(value);\n            }\n            if (!value) {\n                this._clearPreviousSelectedOption(null, false);\n            }\n            else if (this.panelOpen && !this.autocomplete.requireSelection) {\n                // Note that we don't reset this when `requireSelection` is enabled,\n                // because the option will be reset when the panel is closed.\n                const selectedOption = this.autocomplete.options?.find(option => option.selected);\n                if (selectedOption) {\n                    const display = this._getDisplayValue(selectedOption.value);\n                    if (value !== display) {\n                        selectedOption.deselect(false);\n                    }\n                }\n            }\n            if (this._canOpen() && this._document.activeElement === event.target) {\n                // When the `input` event fires, the input's value will have already changed. This means\n                // that if we take the `this._element.nativeElement.value` directly, it'll be one keystroke\n                // behind. This can be a problem when the user selects a value, changes a character while\n                // the input still has focus and then clicks away (see #28432). To work around it, we\n                // capture the value in `keydown` so we can use it here.\n                const valueOnAttach = this._valueOnLastKeydown ?? this._element.nativeElement.value;\n                this._valueOnLastKeydown = null;\n                this._openPanelInternal(valueOnAttach);\n            }\n        }\n    }\n    _handleFocus() {\n        if (!this._canOpenOnNextFocus) {\n            this._canOpenOnNextFocus = true;\n        }\n        else if (this._canOpen()) {\n            this._previousValue = this._element.nativeElement.value;\n            this._attachOverlay(this._previousValue);\n            this._floatLabel(true);\n        }\n    }\n    _handleClick() {\n        if (this._canOpen() && !this.panelOpen) {\n            this._openPanelInternal();\n        }\n    }\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @param shouldAnimate Whether the label should be animated when it is floated.\n     */\n    _floatLabel(shouldAnimate = false) {\n        if (this._formField && this._formField.floatLabel === 'auto') {\n            if (shouldAnimate) {\n                this._formField._animateAndLockLabel();\n            }\n            else {\n                this._formField.floatLabel = 'always';\n            }\n            this._manuallyFloatingLabel = true;\n        }\n    }\n    /** If the label has been manually elevated, return it to its normal state. */\n    _resetLabel() {\n        if (this._manuallyFloatingLabel) {\n            if (this._formField) {\n                this._formField.floatLabel = 'auto';\n            }\n            this._manuallyFloatingLabel = false;\n        }\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    _subscribeToClosingActions() {\n        const initialRender = new Observable(subscriber => {\n            afterNextRender(() => {\n                subscriber.next();\n            }, { injector: this._injector });\n        });\n        const optionChanges = this.autocomplete.options.changes.pipe(tap(() => this._positionStrategy.reapplyLastPosition()), \n        // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0));\n        // When the options are initially rendered, and when the option list changes...\n        return (merge(initialRender, optionChanges)\n            .pipe(\n        // create a new stream of panelClosingActions, replacing any previous streams\n        // that were created, and flatten it so our stream only emits closing events...\n        switchMap(() => this._zone.run(() => {\n            // `afterNextRender` always runs outside of the Angular zone, thus we have to re-enter\n            // the Angular zone. This will lead to change detection being called outside of the Angular\n            // zone and the `autocomplete.opened` will also emit outside of the Angular.\n            const wasOpen = this.panelOpen;\n            this._resetActiveItem();\n            this._updatePanelState();\n            this._changeDetectorRef.detectChanges();\n            if (this.panelOpen) {\n                this._overlayRef.updatePosition();\n            }\n            if (wasOpen !== this.panelOpen) {\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n                // `closed` event, because we may not have emitted it. This can happen\n                // - if the users opens the panel and there are no options, but the\n                //   options come in slightly later or as a result of the value changing,\n                // - if the panel is closed after the user entered a string that did not match any\n                //   of the available options,\n                // - if a valid string is entered after an invalid one.\n                if (this.panelOpen) {\n                    this._emitOpened();\n                }\n                else {\n                    this.autocomplete.closed.emit();\n                }\n            }\n            return this.panelClosingActions;\n        })), \n        // when the first closing event occurs...\n        take(1))\n            // set the value, close the panel, and complete.\n            .subscribe(event => this._setValueAndClose(event)));\n    }\n    /**\n     * Emits the opened event once it's known that the panel will be shown and stores\n     * the state of the trigger right before the opening sequence was finished.\n     */\n    _emitOpened() {\n        this.autocomplete.opened.emit();\n    }\n    /** Destroys the autocomplete suggestion panel. */\n    _destroyPanel() {\n        if (this._overlayRef) {\n            this.closePanel();\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n    }\n    /** Given a value, returns the string that should be shown within the input. */\n    _getDisplayValue(value) {\n        const autocomplete = this.autocomplete;\n        return autocomplete && autocomplete.displayWith ? autocomplete.displayWith(value) : value;\n    }\n    _assignOptionValue(value) {\n        const toDisplay = this._getDisplayValue(value);\n        if (value == null) {\n            this._clearPreviousSelectedOption(null, false);\n        }\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n    }\n    _updateNativeInputValue(value) {\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this._formField) {\n            this._formField._control.value = value;\n        }\n        else {\n            this._element.nativeElement.value = value;\n        }\n        this._previousValue = value;\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    _setValueAndClose(event) {\n        const panel = this.autocomplete;\n        const toSelect = event ? event.source : this._pendingAutoselectedOption;\n        if (toSelect) {\n            this._clearPreviousSelectedOption(toSelect);\n            this._assignOptionValue(toSelect.value);\n            // TODO(crisbeto): this should wait until the animation is done, otherwise the value\n            // gets reset while the panel is still animating which looks glitchy. It'll likely break\n            // some tests to change it at this point.\n            this._onChange(toSelect.value);\n            panel._emitSelectEvent(toSelect);\n            this._element.nativeElement.focus();\n        }\n        else if (panel.requireSelection &&\n            this._element.nativeElement.value !== this._valueOnAttach) {\n            this._clearPreviousSelectedOption(null);\n            this._assignOptionValue(null);\n            // Wait for the animation to finish before clearing the form control value, otherwise\n            // the options might change while the animation is running which looks glitchy.\n            if (panel._animationDone) {\n                panel._animationDone.pipe(take(1)).subscribe(() => this._onChange(null));\n            }\n            else {\n                this._onChange(null);\n            }\n        }\n        this.closePanel();\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    _clearPreviousSelectedOption(skip, emitEvent) {\n        // Null checks are necessary here, because the autocomplete\n        // or its options may not have been assigned yet.\n        this.autocomplete?.options?.forEach(option => {\n            if (option !== skip && option.selected) {\n                option.deselect(emitEvent);\n            }\n        });\n    }\n    _openPanelInternal(valueOnAttach = this._element.nativeElement.value) {\n        this._attachOverlay(valueOnAttach);\n        this._floatLabel();\n        // Add aria-owns attribute when the autocomplete becomes visible.\n        if (this._trackedModal) {\n            const panelId = this.autocomplete.id;\n            addAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n        }\n    }\n    _attachOverlay(valueOnAttach) {\n        if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatAutocompleteMissingPanelError();\n        }\n        let overlayRef = this._overlayRef;\n        if (!overlayRef) {\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n                id: this._formField?.getLabelId(),\n            });\n            overlayRef = this._overlay.create(this._getOverlayConfig());\n            this._overlayRef = overlayRef;\n            this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n                if (this.panelOpen && overlayRef) {\n                    overlayRef.updateSize({ width: this._getPanelWidth() });\n                }\n            });\n            // Subscribe to the breakpoint events stream to detect when screen is in\n            // handsetLandscape.\n            this._handsetLandscapeSubscription = this._breakpointObserver\n                .observe(Breakpoints.HandsetLandscape)\n                .subscribe(result => {\n                const isHandsetLandscape = result.matches;\n                // Check if result.matches Breakpoints.HandsetLandscape. Apply HandsetLandscape\n                // settings to prevent overlay cutoff in that breakpoint. Fixes b/284148377\n                if (isHandsetLandscape) {\n                    this._positionStrategy\n                        .withFlexibleDimensions(true)\n                        .withGrowAfterOpen(true)\n                        .withViewportMargin(8);\n                }\n                else {\n                    this._positionStrategy\n                        .withFlexibleDimensions(false)\n                        .withGrowAfterOpen(false)\n                        .withViewportMargin(0);\n                }\n            });\n        }\n        else {\n            // Update the trigger, panel width and direction, in case anything has changed.\n            this._positionStrategy.setOrigin(this._getConnectedElement());\n            overlayRef.updateSize({ width: this._getPanelWidth() });\n        }\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this._portal);\n            this._valueOnAttach = valueOnAttach;\n            this._valueOnLastKeydown = null;\n            this._closingActionsSubscription = this._subscribeToClosingActions();\n        }\n        const wasOpen = this.panelOpen;\n        this.autocomplete._isOpen = this._overlayAttached = true;\n        this.autocomplete._latestOpeningTrigger = this;\n        this.autocomplete._setColor(this._formField?.color);\n        this._updatePanelState();\n        this._applyModalPanelOwnership();\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this._emitOpened();\n        }\n    }\n    /** Updates the panel's visibility state and any trigger state tied to id. */\n    _updatePanelState() {\n        this.autocomplete._setVisibility();\n        // Note that here we subscribe and unsubscribe based on the panel's visiblity state,\n        // because the act of subscribing will prevent events from reaching other overlays and\n        // we don't want to block the events if there are no options.\n        if (this.panelOpen) {\n            const overlayRef = this._overlayRef;\n            if (!this._keydownSubscription) {\n                // Use the `keydownEvents` in order to take advantage of\n                // the overlay event targeting provided by the CDK overlay.\n                this._keydownSubscription = overlayRef.keydownEvents().subscribe(this._handlePanelKeydown);\n            }\n            if (!this._outsideClickSubscription) {\n                // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n                // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n                // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n                this._outsideClickSubscription = overlayRef.outsidePointerEvents().subscribe();\n            }\n        }\n        else {\n            this._keydownSubscription?.unsubscribe();\n            this._outsideClickSubscription?.unsubscribe();\n            this._keydownSubscription = this._outsideClickSubscription = null;\n        }\n    }\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._getOverlayPosition(),\n            scrollStrategy: this._scrollStrategy(),\n            width: this._getPanelWidth(),\n            direction: this._dir ?? undefined,\n            panelClass: this._defaults?.overlayPanelClass,\n        });\n    }\n    _getOverlayPosition() {\n        // Set default Overlay Position\n        const strategy = this._overlay\n            .position()\n            .flexibleConnectedTo(this._getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false);\n        this._setStrategyPositions(strategy);\n        this._positionStrategy = strategy;\n        return strategy;\n    }\n    /** Sets the positions on a position strategy based on the directive's input state. */\n    _setStrategyPositions(positionStrategy) {\n        // Note that we provide horizontal fallback positions, even though by default the dropdown\n        // width matches the input, because consumers can override the width. See #18854.\n        const belowPositions = [\n            { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n            { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' },\n        ];\n        // The overlay edge connected to the trigger should have squared corners, while\n        // the opposite end has rounded corners. We apply a CSS class to swap the\n        // border-radius based on the overlay position.\n        const panelClass = this._aboveClass;\n        const abovePositions = [\n            { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },\n            { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass },\n        ];\n        let positions;\n        if (this.position === 'above') {\n            positions = abovePositions;\n        }\n        else if (this.position === 'below') {\n            positions = belowPositions;\n        }\n        else {\n            positions = [...belowPositions, ...abovePositions];\n        }\n        positionStrategy.withPositions(positions);\n    }\n    _getConnectedElement() {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n    }\n    _getPanelWidth() {\n        return this.autocomplete.panelWidth || this._getHostWidth();\n    }\n    /** Returns the width of the input element, so the panel width can match it. */\n    _getHostWidth() {\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n     * option.\n     *\n     * If the consumer opted-in to automatically activatating the first option, activate the first\n     * *enabled* option.\n     */\n    _resetActiveItem() {\n        const autocomplete = this.autocomplete;\n        if (autocomplete.autoActiveFirstOption) {\n            // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n            // because it activates the first option that passes the skip predicate, rather than the\n            // first *enabled* option.\n            let firstEnabledOptionIndex = -1;\n            for (let index = 0; index < autocomplete.options.length; index++) {\n                const option = autocomplete.options.get(index);\n                if (!option.disabled) {\n                    firstEnabledOptionIndex = index;\n                    break;\n                }\n            }\n            autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n        }\n        else {\n            autocomplete._keyManager.setActiveItem(-1);\n        }\n    }\n    /** Determines whether the panel can be opened. */\n    _canOpen() {\n        const element = this._element.nativeElement;\n        return !element.readOnly && !element.disabled && !this.autocompleteDisabled;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document?.defaultView || window;\n    }\n    /** Scrolls to a particular option in the list. */\n    _scrollToOption(index) {\n        // Given that we are not actually focusing active options, we must manually adjust scroll\n        // to reveal options below the fold. First, we find the offset of the option from the top\n        // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n        // the panel height + the option height, so the active option will be just visible at the\n        // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n        // will become the offset. If that offset is visible within the panel already, the scrollTop is\n        // not adjusted.\n        const autocomplete = this.autocomplete;\n        const labelCount = _countGroupLabelsBeforeOption(index, autocomplete.options, autocomplete.optionGroups);\n        if (index === 0 && labelCount === 1) {\n            // If we've got one group label before the option and we're at the top option,\n            // scroll the list to the top. This is better UX than scrolling the list to the\n            // top of the option, because it allows the user to read the top group's label.\n            autocomplete._setScrollTop(0);\n        }\n        else if (autocomplete.panel) {\n            const option = autocomplete.options.toArray()[index];\n            if (option) {\n                const element = option._getHostElement();\n                const newScrollPosition = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);\n                autocomplete._setScrollTop(newScrollPosition);\n            }\n        }\n    }\n    /**\n     * If the autocomplete trigger is inside of an `aria-modal` element, connect\n     * that modal to the options panel with `aria-owns`.\n     *\n     * For some browser + screen reader combinations, when navigation is inside\n     * of an `aria-modal` element, the screen reader treats everything outside\n     * of that modal as hidden or invisible.\n     *\n     * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n     * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n     * from reaching the panel.\n     *\n     * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n     * the options panel. This effectively communicates to assistive technology that the\n     * options panel is part of the same interaction as the modal.\n     *\n     * At time of this writing, this issue is present in VoiceOver.\n     * See https://github.com/angular/components/issues/20694\n     */\n    _applyModalPanelOwnership() {\n        // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n        // the `LiveAnnouncer` and any other usages.\n        //\n        // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n        // section of the DOM we need to look through. This should cover all the cases we support, but\n        // the selector can be expanded if it turns out to be too narrow.\n        const modal = this._element.nativeElement.closest('body > .cdk-overlay-container [aria-modal=\"true\"]');\n        if (!modal) {\n            // Most commonly, the autocomplete trigger is not inside a modal.\n            return;\n        }\n        const panelId = this.autocomplete.id;\n        if (this._trackedModal) {\n            removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n        }\n        addAriaReferencedId(modal, 'aria-owns', panelId);\n        this._trackedModal = modal;\n    }\n    /** Clears the references to the listbox overlay element from the modal it was added to. */\n    _clearFromModal() {\n        if (this._trackedModal) {\n            const panelId = this.autocomplete.id;\n            removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n            this._trackedModal = null;\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteTrigger, deps: [{ token: i0.ElementRef }, { token: i1$1.Overlay }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: MAT_AUTOCOMPLETE_SCROLL_STRATEGY }, { token: i2.Directionality, optional: true }, { token: MAT_FORM_FIELD, host: true, optional: true }, { token: DOCUMENT, optional: true }, { token: i3.ViewportRuler }, { token: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"18.2.0-next.2\", type: MatAutocompleteTrigger, isStandalone: true, selector: \"input[matAutocomplete], textarea[matAutocomplete]\", inputs: { autocomplete: [\"matAutocomplete\", \"autocomplete\"], position: [\"matAutocompletePosition\", \"position\"], connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"], autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"], autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\", booleanAttribute] }, host: { listeners: { \"focusin\": \"_handleFocus()\", \"blur\": \"_onTouched()\", \"input\": \"_handleInput($event)\", \"keydown\": \"_handleKeydown($event)\", \"click\": \"_handleClick()\" }, properties: { \"attr.autocomplete\": \"autocompleteAttribute\", \"attr.role\": \"autocompleteDisabled ? null : \\\"combobox\\\"\", \"attr.aria-autocomplete\": \"autocompleteDisabled ? null : \\\"list\\\"\", \"attr.aria-activedescendant\": \"(panelOpen && activeOption) ? activeOption.id : null\", \"attr.aria-expanded\": \"autocompleteDisabled ? null : panelOpen.toString()\", \"attr.aria-controls\": \"(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id\", \"attr.aria-haspopup\": \"autocompleteDisabled ? null : \\\"listbox\\\"\" }, classAttribute: \"mat-mdc-autocomplete-trigger\" }, providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR], exportAs: [\"matAutocompleteTrigger\"], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n                    host: {\n                        'class': 'mat-mdc-autocomplete-trigger',\n                        '[attr.autocomplete]': 'autocompleteAttribute',\n                        '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                        '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                        '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                        '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                        '[attr.aria-controls]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                        '[attr.aria-haspopup]': 'autocompleteDisabled ? null : \"listbox\"',\n                        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                        // a little earlier. This avoids issues where IE delays the focusing of the input.\n                        '(focusin)': '_handleFocus()',\n                        '(blur)': '_onTouched()',\n                        '(input)': '_handleInput($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(click)': '_handleClick()',\n                    },\n                    exportAs: 'matAutocompleteTrigger',\n                    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n                    standalone: true,\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1$1.Overlay }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY]\n                }] }, { type: i2.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: i4.MatFormField, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_FORM_FIELD]\n                }, {\n                    type: Host\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i3.ViewportRuler }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\n                }] }], propDecorators: { autocomplete: [{\n                type: Input,\n                args: ['matAutocomplete']\n            }], position: [{\n                type: Input,\n                args: ['matAutocompletePosition']\n            }], connectedTo: [{\n                type: Input,\n                args: ['matAutocompleteConnectedTo']\n            }], autocompleteAttribute: [{\n                type: Input,\n                args: ['autocomplete']\n            }], autocompleteDisabled: [{\n                type: Input,\n                args: [{ alias: 'matAutocompleteDisabled', transform: booleanAttribute }]\n            }] } });\n\nclass MatAutocompleteModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteModule, imports: [OverlayModule,\n            MatOptionModule,\n            MatCommonModule,\n            CommonModule,\n            MatAutocomplete,\n            MatAutocompleteTrigger,\n            MatAutocompleteOrigin], exports: [CdkScrollableModule,\n            MatAutocomplete,\n            MatOptionModule,\n            MatCommonModule,\n            MatAutocompleteTrigger,\n            MatAutocompleteOrigin] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteModule, providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [OverlayModule,\n            MatOptionModule,\n            MatCommonModule,\n            CommonModule, CdkScrollableModule,\n            MatOptionModule,\n            MatCommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0-next.2\", ngImport: i0, type: MatAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        OverlayModule,\n                        MatOptionModule,\n                        MatCommonModule,\n                        CommonModule,\n                        MatAutocomplete,\n                        MatAutocompleteTrigger,\n                        MatAutocompleteOrigin,\n                    ],\n                    exports: [\n                        CdkScrollableModule,\n                        MatAutocomplete,\n                        MatOptionModule,\n                        MatCommonModule,\n                        MatAutocompleteTrigger,\n                        MatAutocompleteOrigin,\n                    ],\n                    providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, getMatAutocompleteMissingPanelError };\n"],"mappings":"AAAA,OAAO,KAAKA,EAAE,MAAM,eAAe;AACnC,SAASC,cAAc,EAAEC,YAAY,EAAEC,gBAAgB,EAAEC,WAAW,EAAEC,SAAS,EAAEC,iBAAiB,EAAEC,uBAAuB,EAAEC,MAAM,EAAEC,SAAS,EAAEC,eAAe,EAAEC,KAAK,EAAEC,MAAM,EAAEC,SAAS,EAAEC,UAAU,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,QAAQ,QAAQ,eAAe;AACzR,SAASC,2BAA2B,EAAEC,SAAS,EAAEC,YAAY,EAAEC,wBAAwB,EAAEC,6BAA6B,EAAEC,wBAAwB,EAAEC,eAAe,EAAEC,eAAe,QAAQ,wBAAwB;AAAC,MAAAC,GAAA;AAAA,MAAAC,GAAA;AAAA,SAAAC,uCAAAC,EAAA,EAAAC,GAAA;EAAA,IAAAD,EAAA;IAAA,MAAAE,GAAA,GAuMxGlC,EAAE,CAAAmC,gBAAA;IAAFnC,EAAE,CAAAoC,cAAA,eACghE,CAAC;IADnhEpC,EAAE,CAAAqC,UAAA,kCAAAC,oFAAAC,MAAA;MAAFvC,EAAE,CAAAwC,aAAA,CAAAN,GAAA;MAAA,MAAAO,MAAA,GAAFzC,EAAE,CAAA0C,aAAA;MAAA,OAAF1C,EAAE,CAAA2C,WAAA,CACu+DF,MAAA,CAAAG,cAAA,CAAAC,IAAA,CAAAN,MAA0B,CAAC;IAAA,CAAC,CAAC;IADtgEvC,EAAE,CAAA8C,YAAA,EAC+iE,CAAC;IADljE9C,EAAE,CAAA+C,YAAA,CACyjE,CAAC;EAAA;EAAA,IAAAf,EAAA;IAAA,MAAAgB,cAAA,GAAAf,GAAA,CAAAgB,EAAA;IAAA,MAAAR,MAAA,GAD5jEzC,EAAE,CAAA0C,aAAA;IAAF1C,EAAE,CAAAkD,UAAA,CAAAT,MAAA,CAAAU,UAC8hD,CAAC;IADjiDnD,EAAE,CAAAoD,WAAA,iCAAAX,MAAA,CAAAY,SACslD,CAAC,iCAAAZ,MAAA,CAAAY,SAAuD,CAAC,gBAAAZ,MAAA,CAAAa,MAAA,cAAiD,CAAC,eAAAb,MAAA,CAAAa,MAAA,aAA+C,CAAC,aAAAb,MAAA,CAAAa,MAAA,WAA2C,CAAC;IAD/xDtD,EAAE,CAAAuD,UAAA,OAAAd,MAAA,CAAAQ,EACkgD,CAAC,oBAAAR,MAAA,CAAAe,MAAA,uBAAoc,CAAC;IAD18DxD,EAAE,CAAAyD,WAAA,eAAAhB,MAAA,CAAAiB,SAAA,6BAAAjB,MAAA,CAAAkB,uBAAA,CAAAX,cAAA;EAAA;AAAA;AAtM7G,SAASY,WAAW,EAAEtC,SAAS,QAAQ,wBAAwB;AAC/D,SAASuC,QAAQ,EAAEC,YAAY,QAAQ,iBAAiB;AACxD,OAAO,KAAKC,EAAE,MAAM,wBAAwB;AAC5C,SAASC,mBAAmB,QAAQ,wBAAwB;AAC5D,OAAO,KAAKC,IAAI,MAAM,sBAAsB;AAC5C,SAASC,OAAO,EAAEC,aAAa,EAAEC,aAAa,QAAQ,sBAAsB;AAC5E,SAASC,0BAA0B,EAAEC,sBAAsB,EAAEC,mBAAmB,QAAQ,mBAAmB;AAC3G,OAAO,KAAKC,EAAE,MAAM,uBAAuB;AAC3C,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,EAAEC,KAAK,EAAEC,OAAO,QAAQ,qBAAqB;AACvF,SAASC,YAAY,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,EAAE,EAAEC,SAAS,EAAEC,UAAU,QAAQ,MAAM;AACrF,SAASC,MAAM,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,UAAU,EAAEC,GAAG,QAAQ,uBAAuB;AAChG,SAASC,kBAAkB,EAAEC,WAAW,QAAQ,qBAAqB;AACrE,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,iBAAiB,QAAQ,gBAAgB;AAClD,OAAO,KAAKC,EAAE,MAAM,8BAA8B;AAClD,SAASC,cAAc,QAAQ,8BAA8B;AAC7D,SAASC,SAAS,EAAEC,SAAS,EAAEC,MAAM,EAAEC,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAEC,IAAI,QAAQ,gBAAgB;AACpF,OAAO,KAAKC,EAAE,MAAM,mBAAmB;;AAEvC;AACA;AACA,MAAMC,cAAc,gBAAGjC,OAAO,CAAC,gBAAgB,EAAE,cAC7CC,KAAK,CAAC,cAAc,eAAEC,KAAK,CAAC;EACxBgC,OAAO,EAAE,CAAC;EACVC,SAAS,EAAE;AACf,CAAC,CAAC,CAAC,eACHhC,UAAU,CAAC,2BAA2B,EAAE,cACpCC,KAAK,CAAC,cACFC,OAAO,CAAC,cAAc,eAAEH,KAAK,CAAC;EAAEgC,OAAO,EAAE;AAAE,CAAC,CAAC,CAAC,eAC9C7B,OAAO,CAAC,kCAAkC,eAAEH,KAAK,CAAC;EAAEiC,SAAS,EAAE;AAAY,CAAC,CAAC,CAAC,CACjF,CAAC,CACL,CAAC,eACFhC,UAAU,CAAC,2BAA2B,EAAE,cAACE,OAAO,CAAC,eAAe,eAAEH,KAAK,CAAC;EAAEgC,OAAO,EAAE;AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7F,CAAC;;AAEF;AACA;AACA;AACA;AACA,IAAIE,4BAA4B,GAAG,CAAC;AACpC;AACA,MAAMC,4BAA4B,CAAC;EAC/BC,WAAWA,CAAA,CACX;EACAC,MAAM,EACN;EACAC,MAAM,EAAE;IACJ,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACxB;AACJ;AACA;AACA,MAAMC,gCAAgC,gBAAG,IAAIlH,cAAc,CAAC,kCAAkC,EAAE;EAC5FmH,UAAU,EAAE,MAAM;EAClBC,OAAO,EAAEC;AACb,CAAC,CAAC;AACF;AACA,SAASA,wCAAwCA,CAAA,EAAG;EAChD,OAAO;IACHC,qBAAqB,EAAE,KAAK;IAC5BC,sBAAsB,EAAE,KAAK;IAC7BC,4BAA4B,EAAE,KAAK;IACnCC,gBAAgB,EAAE;EACtB,CAAC;AACL;AACA;AAAA,IACMC,eAAe;EAArB,MAAMA,eAAe,CAAC;IAClB;IACA,IAAInE,MAAMA,CAAA,EAAG;MACT,OAAO,IAAI,CAACoE,OAAO,IAAI,IAAI,CAACvE,SAAS;IACzC;IACA;IACAwE,SAASA,CAACC,KAAK,EAAE;MACb,IAAI,CAACxE,MAAM,GAAGwE,KAAK;MACnB,IAAI,CAACC,kBAAkB,CAACC,YAAY,CAAC,CAAC;IAC1C;IACA;AACJ;AACA;AACA;IACI,IAAIC,SAASA,CAACH,KAAK,EAAE;MACjB,IAAI,CAAC3E,UAAU,GAAG2E,KAAK;MACvB,IAAI,CAACI,WAAW,CAACC,aAAa,CAACC,SAAS,GAAG,EAAE;IACjD;IACA;IACA,IAAIX,4BAA4BA,CAAA,EAAG;MAC/B,OAAO,IAAI,CAACY,6BAA6B;IAC7C;IACA,IAAIZ,4BAA4BA,CAACK,KAAK,EAAE;MACpC,IAAI,CAACO,6BAA6B,GAAGP,KAAK;MAC1C,IAAI,CAACQ,qBAAqB,CAAC,CAAC;IAChC;IACA;IACAA,qBAAqBA,CAAA,EAAG;MACpB,IAAI,IAAI,CAACC,OAAO,EAAE;QACd,KAAK,MAAMrB,MAAM,IAAI,IAAI,CAACqB,OAAO,EAAE;UAC/BrB,MAAM,CAACa,kBAAkB,CAACC,YAAY,CAAC,CAAC;QAC5C;MACJ;IACJ;IACAhB,WAAWA,CAACe,kBAAkB,EAAEG,WAAW,EAAEM,SAAS,EAAEC,QAAQ,EAAE;MAC9D,IAAI,CAACV,kBAAkB,GAAGA,kBAAkB;MAC5C,IAAI,CAACG,WAAW,GAAGA,WAAW;MAC9B,IAAI,CAACM,SAAS,GAAGA,SAAS;MAC1B,IAAI,CAACE,oBAAoB,GAAG1D,YAAY,CAAC2D,KAAK;MAC9C;MACA,IAAI,CAAC/F,cAAc,GAAG,IAAI1C,YAAY,CAAC,CAAC;MACxC;MACA,IAAI,CAACmD,SAAS,GAAG,KAAK;MACtB,IAAI,CAACuE,OAAO,GAAG,KAAK;MACpB;MACA,IAAI,CAACgB,WAAW,GAAG,IAAI;MACvB;MACA,IAAI,CAACC,cAAc,GAAG,IAAI3I,YAAY,CAAC,CAAC;MACxC;MACA,IAAI,CAAC4I,MAAM,GAAG,IAAI5I,YAAY,CAAC,CAAC;MAChC;MACA,IAAI,CAAC6I,MAAM,GAAG,IAAI7I,YAAY,CAAC,CAAC;MAChC;MACA,IAAI,CAAC8I,eAAe,GAAG,IAAI9I,YAAY,CAAC,CAAC;MACzC;MACA,IAAI,CAAC+C,EAAE,GAAG,oBAAoB6D,4BAA4B,EAAE,EAAE;MAC9D;MACA;MACA;MACA;MACA,IAAI,CAACmC,WAAW,GAAGR,QAAQ,EAAES,MAAM,IAAI,KAAK;MAC5C,IAAI,CAAC3B,qBAAqB,GAAG,CAAC,CAACiB,SAAS,CAACjB,qBAAqB;MAC9D,IAAI,CAACC,sBAAsB,GAAG,CAAC,CAACgB,SAAS,CAAChB,sBAAsB;MAChE,IAAI,CAACE,gBAAgB,GAAG,CAAC,CAACc,SAAS,CAACd,gBAAgB;MACpD,IAAI,CAACW,6BAA6B,GAAG,IAAI,CAACG,SAAS,CAACf,4BAA4B,IAAI,KAAK;IAC7F;IACA0B,kBAAkBA,CAAA,EAAG;MACjB,IAAI,CAACC,WAAW,GAAG,IAAI/E,0BAA0B,CAAC,IAAI,CAACkE,OAAO,CAAC,CAC1Dc,QAAQ,CAAC,CAAC,CACVC,aAAa,CAAC,IAAI,CAACC,cAAc,CAAC;MACvC,IAAI,CAACb,oBAAoB,GAAG,IAAI,CAACU,WAAW,CAACI,MAAM,CAACC,SAAS,CAACC,KAAK,IAAI;QACnE,IAAI,IAAI,CAAClG,MAAM,EAAE;UACb,IAAI,CAACwF,eAAe,CAACW,IAAI,CAAC;YAAE1C,MAAM,EAAE,IAAI;YAAEC,MAAM,EAAE,IAAI,CAACqB,OAAO,CAACqB,OAAO,CAAC,CAAC,CAACF,KAAK,CAAC,IAAI;UAAK,CAAC,CAAC;QAC9F;MACJ,CAAC,CAAC;MACF;MACA,IAAI,CAACG,cAAc,CAAC,CAAC;IACzB;IACAC,WAAWA,CAAA,EAAG;MACV,IAAI,CAACV,WAAW,EAAEW,OAAO,CAAC,CAAC;MAC3B,IAAI,CAACrB,oBAAoB,CAACsB,WAAW,CAAC,CAAC;MACvC,IAAI,CAACpH,cAAc,CAACqH,QAAQ,CAAC,CAAC;IAClC;IACA;AACJ;AACA;AACA;IACIC,aAAaA,CAACC,SAAS,EAAE;MACrB,IAAI,IAAI,CAACC,KAAK,EAAE;QACZ,IAAI,CAACA,KAAK,CAACjC,aAAa,CAACgC,SAAS,GAAGA,SAAS;MAClD;IACJ;IACA;IACAE,aAAaA,CAAA,EAAG;MACZ,OAAO,IAAI,CAACD,KAAK,GAAG,IAAI,CAACA,KAAK,CAACjC,aAAa,CAACgC,SAAS,GAAG,CAAC;IAC9D;IACA;IACAN,cAAcA,CAAA,EAAG;MACb,IAAI,CAACxG,SAAS,GAAG,CAAC,CAAC,IAAI,CAACkF,OAAO,CAAC+B,MAAM;MACtC,IAAI,CAACvC,kBAAkB,CAACC,YAAY,CAAC,CAAC;IAC1C;IACA;IACAuC,gBAAgBA,CAACrD,MAAM,EAAE;MACrB,MAAMsD,KAAK,GAAG,IAAIzD,4BAA4B,CAAC,IAAI,EAAEG,MAAM,CAAC;MAC5D,IAAI,CAAC2B,cAAc,CAACc,IAAI,CAACa,KAAK,CAAC;IACnC;IACA;IACA7G,uBAAuBA,CAAC8G,OAAO,EAAE;MAC7B,IAAI,IAAI,CAAC/G,SAAS,EAAE;QAChB,OAAO,IAAI;MACf;MACA,MAAMgH,eAAe,GAAGD,OAAO,GAAGA,OAAO,GAAG,GAAG,GAAG,EAAE;MACpD,OAAO,IAAI,CAACE,cAAc,GAAGD,eAAe,GAAG,IAAI,CAACC,cAAc,GAAGF,OAAO;IAChF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAlB,cAAcA,CAAA,EAAG;MACb,OAAO,KAAK;IAChB;IAAC,QAAAqB,CAAA,GACQ,IAAI,CAACC,IAAI,YAAAC,wBAAAC,iBAAA;MAAA,YAAAA,iBAAA,IAA+FpD,eAAe,EAAzB3H,EAAE,CAAAgL,iBAAA,CAAyChL,EAAE,CAACiL,iBAAiB,GAA/DjL,EAAE,CAAAgL,iBAAA,CAA0EhL,EAAE,CAACkL,UAAU,GAAzFlL,EAAE,CAAAgL,iBAAA,CAAoG7D,gCAAgC,GAAtInH,EAAE,CAAAgL,iBAAA,CAAiJxG,EAAE,CAAC2G,QAAQ;IAAA,CAA4C;IAAA,QAAAC,EAAA,GACxS,IAAI,CAACC,IAAI,kBADqFrL,EAAE,CAAAsL,iBAAA;MAAAC,IAAA,EACJ5D,eAAe;MAAA6D,SAAA;MAAAC,cAAA,WAAAC,+BAAA1J,EAAA,EAAAC,GAAA,EAAA0J,QAAA;QAAA,IAAA3J,EAAA;UADbhC,EAAE,CAAA4L,cAAA,CAAAD,QAAA,EACm/BrK,SAAS;UAD9/BtB,EAAE,CAAA4L,cAAA,CAAAD,QAAA,EAC8jCpK,YAAY;QAAA;QAAA,IAAAS,EAAA;UAAA,IAAA6J,EAAA;UAD5kC7L,EAAE,CAAA8L,cAAA,CAAAD,EAAA,GAAF7L,EAAE,CAAA+L,WAAA,QAAA9J,GAAA,CAAAsG,OAAA,GAAAsD,EAAA;UAAF7L,EAAE,CAAA8L,cAAA,CAAAD,EAAA,GAAF7L,EAAE,CAAA+L,WAAA,QAAA9J,GAAA,CAAA+J,YAAA,GAAAH,EAAA;QAAA;MAAA;MAAAI,SAAA,WAAAC,sBAAAlK,EAAA,EAAAC,GAAA;QAAA,IAAAD,EAAA;UAAFhC,EAAE,CAAAmM,WAAA,CACoqC/L,WAAW;UADjrCJ,EAAE,CAAAmM,WAAA,CAAAtK,GAAA;QAAA;QAAA,IAAAG,EAAA;UAAA,IAAA6J,EAAA;UAAF7L,EAAE,CAAA8L,cAAA,CAAAD,EAAA,GAAF7L,EAAE,CAAA+L,WAAA,QAAA9J,GAAA,CAAAmK,QAAA,GAAAP,EAAA,CAAAQ,KAAA;UAAFrM,EAAE,CAAA8L,cAAA,CAAAD,EAAA,GAAF7L,EAAE,CAAA+L,WAAA,QAAA9J,GAAA,CAAAmI,KAAA,GAAAyB,EAAA,CAAAQ,KAAA;QAAA;MAAA;MAAAC,SAAA;MAAAC,MAAA;QAAA7I,SAAA;QAAAiH,cAAA;QAAA/B,WAAA;QAAArB,qBAAA,wDAC8QpH,gBAAgB;QAAAqH,sBAAA,0DAAgFrH,gBAAgB;QAAAuH,gBAAA,8CAA8DvH,gBAAgB;QAAAqM,UAAA;QAAAC,aAAA,wCAA+EtM,gBAAgB;QAAA8H,SAAA;QAAAR,4BAAA,sEAAqItH,gBAAgB;MAAA;MAAAuM,OAAA;QAAA7D,cAAA;QAAAC,MAAA;QAAAC,MAAA;QAAAC,eAAA;MAAA;MAAA2D,QAAA;MAAAC,UAAA;MAAAC,QAAA,GADlsB7M,EAAE,CAAA8M,kBAAA,CACy3B,CAAC;QAAEC,OAAO,EAAE1L,2BAA2B;QAAE2L,WAAW,EAAErF;MAAgB,CAAC,CAAC,GADn8B3H,EAAE,CAAAiN,wBAAA,EAAFjN,EAAE,CAAAkN,mBAAA;MAAAC,kBAAA,EAAArL,GAAA;MAAAsL,KAAA;MAAAC,IAAA;MAAAC,MAAA;MAAAlB,QAAA,WAAAmB,yBAAAvL,EAAA,EAAAC,GAAA;QAAA,IAAAD,EAAA;UAAFhC,EAAE,CAAAwN,eAAA;UAAFxN,EAAE,CAAAyN,UAAA,IAAA1L,sCAAA,sBACi4C,CAAC;QAAA;MAAA;MAAA2L,MAAA;MAAAC,aAAA;MAAAC,IAAA;QAAAC,SAAA,EAAksD,CAAClH,cAAc;MAAC;MAAAmH,eAAA;IAAA,EAAiG;EAClyG;EAAC,OArIKnG,eAAe;AAAA;AAsIrB;EAAA,QAAAoG,SAAA,oBAAAA,SAAA;AAAA;;AA0DA;AACA;AACA;AACA;AAHA,IAIMC,qBAAqB;EAA3B,MAAMA,qBAAqB,CAAC;IACxBhH,WAAWA,CAAA,CACX;IACAiH,UAAU,EAAE;MACR,IAAI,CAACA,UAAU,GAAGA,UAAU;IAChC;IAAC,QAAArD,CAAA,GACQ,IAAI,CAACC,IAAI,YAAAqD,8BAAAnD,iBAAA;MAAA,YAAAA,iBAAA,IAA+FiD,qBAAqB,EAvE/BhO,EAAE,CAAAgL,iBAAA,CAuE+ChL,EAAE,CAACkL,UAAU;IAAA,CAA4C;IAAA,QAAAE,EAAA,GACxM,IAAI,CAAC+C,IAAI,kBAxEqFnO,EAAE,CAAAoO,iBAAA;MAAA7C,IAAA,EAwEJyC,qBAAqB;MAAAxC,SAAA;MAAAmB,QAAA;MAAAC,UAAA;IAAA,EAA+G;EAC7O;EAAC,OARKoB,qBAAqB;AAAA;AAS3B;EAAA,QAAAD,SAAA,oBAAAA,SAAA;AAAA;;AASA;AACA;AACA;AACA;AACA,MAAMM,+BAA+B,GAAG;EACpCtB,OAAO,EAAE/G,iBAAiB;EAC1BgH,WAAW,eAAElM,UAAU,CAAC,MAAMwN,sBAAsB,CAAC;EACrDC,KAAK,EAAE;AACX,CAAC;AACD;AACA;AACA;AACA;AACA,SAASC,mCAAmCA,CAAA,EAAG;EAC3C,OAAOC,KAAK,CAAC,kEAAkE,GAC3E,4EAA4E,GAC5E,iEAAiE,CAAC;AAC1E;AACA;AACA,MAAMC,gCAAgC,gBAAG,IAAIzO,cAAc,CAAC,kCAAkC,EAAE;EAC5FmH,UAAU,EAAE,MAAM;EAClBC,OAAO,EAAEA,CAAA,KAAM;IACX,MAAMsH,OAAO,GAAG5N,MAAM,CAACmD,OAAO,CAAC;IAC/B,OAAO,MAAMyK,OAAO,CAACC,gBAAgB,CAACC,UAAU,CAAC,CAAC;EACtD;AACJ,CAAC,CAAC;AACF;AACA,SAASC,wCAAwCA,CAACH,OAAO,EAAE;EACvD,OAAO,MAAMA,OAAO,CAACC,gBAAgB,CAACC,UAAU,CAAC,CAAC;AACtD;AACA;AACA,MAAME,iDAAiD,GAAG;EACtDhC,OAAO,EAAE2B,gCAAgC;EACzCM,IAAI,EAAE,CAAC9K,OAAO,CAAC;EACf+K,UAAU,EAAEH;AAChB,CAAC;AACD;AAAA,IACMR,sBAAsB;EAA5B,MAAMA,sBAAsB,CAAC;IACzBtH,WAAWA,CAACkI,QAAQ,EAAEC,QAAQ,EAAEC,iBAAiB,EAAEC,KAAK,EAAEtH,kBAAkB,EAAEuH,cAAc,EAAEC,IAAI,EAAEC,UAAU,EAAEC,SAAS,EAAEC,cAAc,EAAElH,SAAS,EAAE;MAClJ,IAAI,CAAC0G,QAAQ,GAAGA,QAAQ;MACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;MACxB,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;MAC1C,IAAI,CAACC,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACtH,kBAAkB,GAAGA,kBAAkB;MAC5C,IAAI,CAACwH,IAAI,GAAGA,IAAI;MAChB,IAAI,CAACC,UAAU,GAAGA,UAAU;MAC5B,IAAI,CAACC,SAAS,GAAGA,SAAS;MAC1B,IAAI,CAACC,cAAc,GAAGA,cAAc;MACpC,IAAI,CAAClH,SAAS,GAAGA,SAAS;MAC1B,IAAI,CAACmH,mBAAmB,GAAG,KAAK;MAChC;MACA,IAAI,CAACC,sBAAsB,GAAG,KAAK;MACnC;MACA,IAAI,CAACC,qBAAqB,GAAG7K,YAAY,CAAC2D,KAAK;MAC/C;MACA,IAAI,CAACmH,mBAAmB,GAAG/O,MAAM,CAAC8E,kBAAkB,CAAC;MACrD,IAAI,CAACkK,6BAA6B,GAAG/K,YAAY,CAAC2D,KAAK;MACvD;AACR;AACA;AACA;AACA;MACQ,IAAI,CAACqH,mBAAmB,GAAG,IAAI;MAC/B;MACA,IAAI,CAACC,oBAAoB,GAAG,IAAIhL,OAAO,CAAC,CAAC;MACzC;AACR;AACA;AACA;MACQ,IAAI,CAACiL,kBAAkB,GAAG,MAAM;QAC5B;QACA;QACA;QACA,IAAI,CAACF,mBAAmB,GACpB,IAAI,CAACP,SAAS,CAACU,aAAa,KAAK,IAAI,CAACjB,QAAQ,CAAC/G,aAAa,IAAI,IAAI,CAACiI,SAAS;MACtF,CAAC;MACD;MACA,IAAI,CAACC,SAAS,GAAG,MAAM,CAAE,CAAC;MAC1B;MACA,IAAI,CAACC,UAAU,GAAG,MAAM,CAAE,CAAC;MAC3B;AACR;AACA;AACA;AACA;AACA;AACA;MACQ,IAAI,CAACC,QAAQ,GAAG,MAAM;MACtB;AACR;AACA;AACA;MACQ,IAAI,CAACC,qBAAqB,GAAG,KAAK;MAClC,IAAI,CAACC,YAAY,GAAG,IAAIxL,OAAO,CAAC,CAAC;MACjC,IAAI,CAACyL,SAAS,GAAG3P,MAAM,CAACC,QAAQ,CAAC;MACjC;MACA,IAAI,CAAC2P,WAAW,GAAG,kCAAkC;MACrD,IAAI,CAACC,gBAAgB,GAAG,KAAK;MAC7B;MACA,IAAI,CAACC,gBAAgB,GAAG3L,KAAK,CAAC,MAAM;QAChC,MAAMqD,OAAO,GAAG,IAAI,CAACuI,YAAY,GAAG,IAAI,CAACA,YAAY,CAACvI,OAAO,GAAG,IAAI;QACpE,IAAIA,OAAO,EAAE;UACT,OAAOA,OAAO,CAACwI,OAAO,CAACC,IAAI,CAAC7K,SAAS,CAACoC,OAAO,CAAC,EAAEnC,SAAS,CAAC,MAAMjB,KAAK,CAAC,GAAGoD,OAAO,CAACjC,GAAG,CAACY,MAAM,IAAIA,MAAM,CAAC+J,iBAAiB,CAAC,CAAC,CAAC,CAAC;QAC/H;QACA;QACA;QACA,OAAO,IAAI,CAACR,YAAY,CAACO,IAAI,CAAC5K,SAAS,CAAC,MAAM,IAAI,CAACyK,gBAAgB,CAAC,CAAC;MACzE,CAAC,CAAC;MACF;MACA,IAAI,CAACK,mBAAmB,GAAI1G,KAAK,IAAK;QAClC;QACA;QACA,IAAKA,KAAK,CAAC2G,OAAO,KAAK5L,MAAM,IAAI,CAACC,cAAc,CAACgF,KAAK,CAAC,IAClDA,KAAK,CAAC2G,OAAO,KAAK1L,QAAQ,IAAID,cAAc,CAACgF,KAAK,EAAE,QAAQ,CAAE,EAAE;UACjE;UACA;UACA,IAAI,IAAI,CAAC4G,0BAA0B,EAAE;YACjC,IAAI,CAACC,uBAAuB,CAAC,IAAI,CAACC,yBAAyB,IAAI,EAAE,CAAC;YAClE,IAAI,CAACF,0BAA0B,GAAG,IAAI;UAC1C;UACA,IAAI,CAACnB,oBAAoB,CAACpN,IAAI,CAAC,CAAC;UAChC,IAAI,CAAC0O,gBAAgB,CAAC,CAAC;UACvB;UACA;UACA/G,KAAK,CAACgH,eAAe,CAAC,CAAC;UACvBhH,KAAK,CAACiH,cAAc,CAAC,CAAC;QAC1B;MACJ,CAAC;MACD;AACR;AACA;AACA;AACA;MACQ,IAAI,CAACC,aAAa,GAAG,IAAI;MACzB,IAAI,CAACC,eAAe,GAAGrC,cAAc;IACzC;IACAsC,eAAeA,CAAA,EAAG;MACd,IAAI,CAACnB,YAAY,CAAC5N,IAAI,CAAC,CAAC;MACxB,IAAI,CAAC4N,YAAY,CAACxG,QAAQ,CAAC,CAAC;MAC5B,MAAM4H,MAAM,GAAG,IAAI,CAACC,UAAU,CAAC,CAAC;MAChC,IAAI,OAAOD,MAAM,KAAK,WAAW,EAAE;QAC/B,IAAI,CAACxC,KAAK,CAAC0C,iBAAiB,CAAC,MAAMF,MAAM,CAACG,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC9B,kBAAkB,CAAC,CAAC;MAChG;IACJ;IACA+B,WAAWA,CAAClB,OAAO,EAAE;MACjB,IAAIA,OAAO,CAAC,UAAU,CAAC,IAAI,IAAI,CAACmB,iBAAiB,EAAE;QAC/C,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAACD,iBAAiB,CAAC;QAClD,IAAI,IAAI,CAAC9B,SAAS,EAAE;UAChB,IAAI,CAACgC,WAAW,CAACC,cAAc,CAAC,CAAC;QACrC;MACJ;IACJ;IACAvI,WAAWA,CAAA,EAAG;MACV,MAAM+H,MAAM,GAAG,IAAI,CAACC,UAAU,CAAC,CAAC;MAChC,IAAI,OAAOD,MAAM,KAAK,WAAW,EAAE;QAC/BA,MAAM,CAACS,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAACpC,kBAAkB,CAAC;MAC/D;MACA,IAAI,CAACH,6BAA6B,CAAC/F,WAAW,CAAC,CAAC;MAChD,IAAI,CAAC6F,qBAAqB,CAAC7F,WAAW,CAAC,CAAC;MACxC,IAAI,CAAC2F,mBAAmB,GAAG,IAAI;MAC/B,IAAI,CAAC4C,aAAa,CAAC,CAAC;MACpB,IAAI,CAACtC,oBAAoB,CAAChG,QAAQ,CAAC,CAAC;MACpC,IAAI,CAACuI,eAAe,CAAC,CAAC;IAC1B;IACA;IACA,IAAIpC,SAASA,CAAA,EAAG;MACZ,OAAO,IAAI,CAACQ,gBAAgB,IAAI,IAAI,CAACE,YAAY,CAACzN,SAAS;IAC/D;IACA;IACAoP,SAASA,CAAA,EAAG;MACR,IAAI,CAACC,kBAAkB,CAAC,CAAC;IAC7B;IACA;IACAC,UAAUA,CAAA,EAAG;MACT,IAAI,CAACC,WAAW,CAAC,CAAC;MAClB,IAAI,CAAC,IAAI,CAAChC,gBAAgB,EAAE;QACxB;MACJ;MACA,IAAI,IAAI,CAACR,SAAS,EAAE;QAChB;QACA;QACA;QACA;QACA,IAAI,CAACf,KAAK,CAACwD,GAAG,CAAC,MAAM;UACjB,IAAI,CAAC/B,YAAY,CAAC/H,MAAM,CAACY,IAAI,CAAC,CAAC;QACnC,CAAC,CAAC;MACN;MACA;MACA;MACA,IAAI,IAAI,CAACmH,YAAY,CAACgC,qBAAqB,KAAK,IAAI,EAAE;QAClD,IAAI,CAAChC,YAAY,CAAClJ,OAAO,GAAG,KAAK;QACjC,IAAI,CAACkJ,YAAY,CAACgC,qBAAqB,GAAG,IAAI;MAClD;MACA,IAAI,CAAClC,gBAAgB,GAAG,KAAK;MAC7B,IAAI,CAACQ,0BAA0B,GAAG,IAAI;MACtC,IAAI,IAAI,CAACgB,WAAW,IAAI,IAAI,CAACA,WAAW,CAACW,WAAW,CAAC,CAAC,EAAE;QACpD,IAAI,CAACX,WAAW,CAACY,MAAM,CAAC,CAAC;QACzB,IAAI,CAACC,2BAA2B,CAACjJ,WAAW,CAAC,CAAC;MAClD;MACA,IAAI,CAACkJ,iBAAiB,CAAC,CAAC;MACxB;MACA;MACA,IAAI,CAAC,IAAI,CAACvD,mBAAmB,EAAE;QAC3B;QACA;QACA;QACA;QACA,IAAI,CAAC5H,kBAAkB,CAACoL,aAAa,CAAC,CAAC;MAC3C;MACA;MACA,IAAI,IAAI,CAACzB,aAAa,EAAE;QACpBpN,sBAAsB,CAAC,IAAI,CAACoN,aAAa,EAAE,WAAW,EAAE,IAAI,CAACZ,YAAY,CAAC7N,EAAE,CAAC;MACjF;IACJ;IACA;AACJ;AACA;AACA;IACIoP,cAAcA,CAAA,EAAG;MACb,IAAI,IAAI,CAACzB,gBAAgB,EAAE;QACvB,IAAI,CAACwB,WAAW,CAACC,cAAc,CAAC,CAAC;MACrC;IACJ;IACA;AACJ;AACA;AACA;IACI,IAAIe,mBAAmBA,CAAA,EAAG;MACtB,OAAOjO,KAAK,CAAC,IAAI,CAAC0L,gBAAgB,EAAE,IAAI,CAACC,YAAY,CAAC1H,WAAW,CAACiK,MAAM,CAACrC,IAAI,CAAC3K,MAAM,CAAC,MAAM,IAAI,CAACuK,gBAAgB,CAAC,CAAC,EAAE,IAAI,CAACX,oBAAoB,EAAE,IAAI,CAACqD,sBAAsB,CAAC,CAAC,EAAE,IAAI,CAAClB,WAAW,GACxL,IAAI,CAACA,WAAW,CAACmB,WAAW,CAAC,CAAC,CAACvC,IAAI,CAAC3K,MAAM,CAAC,MAAM,IAAI,CAACuK,gBAAgB,CAAC,CAAC,GACxExL,EAAE,CAAC,CAAC,CAAC,CAAC4L,IAAI;MAChB;MACA1K,GAAG,CAACkE,KAAK,IAAKA,KAAK,YAAYhJ,wBAAwB,GAAGgJ,KAAK,GAAG,IAAK,CAAC,CAAC;IAC7E;IACA;IACA,IAAIgJ,YAAYA,CAAA,EAAG;MACf,IAAI,IAAI,CAAC1C,YAAY,IAAI,IAAI,CAACA,YAAY,CAAC1H,WAAW,EAAE;QACpD,OAAO,IAAI,CAAC0H,YAAY,CAAC1H,WAAW,CAACqK,UAAU;MACnD;MACA,OAAO,IAAI;IACf;IACA;IACAH,sBAAsBA,CAAA,EAAG;MACrB,OAAOnO,KAAK,CAACE,SAAS,CAAC,IAAI,CAACoK,SAAS,EAAE,OAAO,CAAC,EAAEpK,SAAS,CAAC,IAAI,CAACoK,SAAS,EAAE,UAAU,CAAC,EAAEpK,SAAS,CAAC,IAAI,CAACoK,SAAS,EAAE,UAAU,CAAC,CAAC,CAACuB,IAAI,CAAC3K,MAAM,CAACmE,KAAK,IAAI;QAChJ;QACA;QACA,MAAMkJ,WAAW,GAAGjP,eAAe,CAAC+F,KAAK,CAAC;QAC1C,MAAMmJ,SAAS,GAAG,IAAI,CAACnE,UAAU,GAC3B,IAAI,CAACA,UAAU,CAACoE,yBAAyB,CAAC,CAAC,CAACzL,aAAa,GACzD,IAAI;QACV,MAAM0L,YAAY,GAAG,IAAI,CAACC,WAAW,GAAG,IAAI,CAACA,WAAW,CAAC7F,UAAU,CAAC9F,aAAa,GAAG,IAAI;QACxF,OAAQ,IAAI,CAACyI,gBAAgB,IACzB8C,WAAW,KAAK,IAAI,CAACxE,QAAQ,CAAC/G,aAAa;QAC3C;QACA;QACA;QACA;QACA,IAAI,CAACsH,SAAS,CAACU,aAAa,KAAK,IAAI,CAACjB,QAAQ,CAAC/G,aAAa,KAC3D,CAACwL,SAAS,IAAI,CAACA,SAAS,CAACI,QAAQ,CAACL,WAAW,CAAC,CAAC,KAC/C,CAACG,YAAY,IAAI,CAACA,YAAY,CAACE,QAAQ,CAACL,WAAW,CAAC,CAAC,IACtD,CAAC,CAAC,IAAI,CAACtB,WAAW,IAClB,CAAC,IAAI,CAACA,WAAW,CAAC4B,cAAc,CAACD,QAAQ,CAACL,WAAW,CAAC;MAC9D,CAAC,CAAC,CAAC;IACP;IACA;IACAO,UAAUA,CAACnM,KAAK,EAAE;MACdoM,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC,CAACC,IAAI,CAAC,MAAM,IAAI,CAACC,kBAAkB,CAACvM,KAAK,CAAC,CAAC;IACpE;IACA;IACAwM,gBAAgBA,CAACC,EAAE,EAAE;MACjB,IAAI,CAAClE,SAAS,GAAGkE,EAAE;IACvB;IACA;IACAC,iBAAiBA,CAACD,EAAE,EAAE;MAClB,IAAI,CAACjE,UAAU,GAAGiE,EAAE;IACxB;IACA;IACAE,gBAAgBA,CAACC,UAAU,EAAE;MACzB,IAAI,CAACxF,QAAQ,CAAC/G,aAAa,CAACwM,QAAQ,GAAGD,UAAU;IACrD;IACAE,cAAcA,CAACpK,KAAK,EAAE;MAClB,MAAM2G,OAAO,GAAG3G,KAAK,CAAC2G,OAAO;MAC7B,MAAM0D,WAAW,GAAGrP,cAAc,CAACgF,KAAK,CAAC;MACzC;MACA;MACA;MACA;MACA,IAAI2G,OAAO,KAAK5L,MAAM,IAAI,CAACsP,WAAW,EAAE;QACpCrK,KAAK,CAACiH,cAAc,CAAC,CAAC;MAC1B;MACA,IAAI,CAACqD,mBAAmB,GAAG,IAAI,CAAC5F,QAAQ,CAAC/G,aAAa,CAACL,KAAK;MAC5D,IAAI,IAAI,CAAC0L,YAAY,IAAIrC,OAAO,KAAKzL,KAAK,IAAI,IAAI,CAAC0K,SAAS,IAAI,CAACyE,WAAW,EAAE;QAC1E,IAAI,CAACrB,YAAY,CAACuB,qBAAqB,CAAC,CAAC;QACzC,IAAI,CAACxD,gBAAgB,CAAC,CAAC;QACvB/G,KAAK,CAACiH,cAAc,CAAC,CAAC;MAC1B,CAAC,MACI,IAAI,IAAI,CAACX,YAAY,EAAE;QACxB,MAAMkE,cAAc,GAAG,IAAI,CAAClE,YAAY,CAAC1H,WAAW,CAACqK,UAAU;QAC/D,MAAMwB,UAAU,GAAG9D,OAAO,KAAK1L,QAAQ,IAAI0L,OAAO,KAAKxL,UAAU;QACjE,IAAIwL,OAAO,KAAKvL,GAAG,IAAKqP,UAAU,IAAI,CAACJ,WAAW,IAAI,IAAI,CAACzE,SAAU,EAAE;UACnE,IAAI,CAACU,YAAY,CAAC1H,WAAW,CAAC8L,SAAS,CAAC1K,KAAK,CAAC;QAClD,CAAC,MACI,IAAIyK,UAAU,IAAI,IAAI,CAACE,QAAQ,CAAC,CAAC,EAAE;UACpC,IAAI,CAACzC,kBAAkB,CAAC,IAAI,CAACoC,mBAAmB,CAAC;QACrD;QACA,IAAIG,UAAU,IAAI,IAAI,CAACnE,YAAY,CAAC1H,WAAW,CAACqK,UAAU,KAAKuB,cAAc,EAAE;UAC3E,IAAI,CAACI,eAAe,CAAC,IAAI,CAACtE,YAAY,CAAC1H,WAAW,CAACiM,eAAe,IAAI,CAAC,CAAC;UACxE,IAAI,IAAI,CAACvE,YAAY,CAACtJ,sBAAsB,IAAI,IAAI,CAACgM,YAAY,EAAE;YAC/D,IAAI,CAAC,IAAI,CAACpC,0BAA0B,EAAE;cAClC,IAAI,CAACE,yBAAyB,GAAG,IAAI,CAACwD,mBAAmB;YAC7D;YACA,IAAI,CAAC1D,0BAA0B,GAAG,IAAI,CAACoC,YAAY;YACnD,IAAI,CAACa,kBAAkB,CAAC,IAAI,CAACb,YAAY,CAAC1L,KAAK,CAAC;UACpD;QACJ;MACJ;IACJ;IACAwN,YAAYA,CAAC9K,KAAK,EAAE;MAChB,IAAI+K,MAAM,GAAG/K,KAAK,CAAC+K,MAAM;MACzB,IAAIzN,KAAK,GAAGyN,MAAM,CAACzN,KAAK;MACxB;MACA,IAAIyN,MAAM,CAAChK,IAAI,KAAK,QAAQ,EAAE;QAC1BzD,KAAK,GAAGA,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG0N,UAAU,CAAC1N,KAAK,CAAC;MAClD;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,IAAI,CAAC2N,cAAc,KAAK3N,KAAK,EAAE;QAC/B,IAAI,CAAC2N,cAAc,GAAG3N,KAAK;QAC3B,IAAI,CAACsJ,0BAA0B,GAAG,IAAI;QACtC;QACA;QACA;QACA,IAAI,CAAC,IAAI,CAACN,YAAY,IAAI,CAAC,IAAI,CAACA,YAAY,CAACpJ,gBAAgB,EAAE;UAC3D,IAAI,CAAC2I,SAAS,CAACvI,KAAK,CAAC;QACzB;QACA,IAAI,CAACA,KAAK,EAAE;UACR,IAAI,CAAC4N,4BAA4B,CAAC,IAAI,EAAE,KAAK,CAAC;QAClD,CAAC,MACI,IAAI,IAAI,CAACtF,SAAS,IAAI,CAAC,IAAI,CAACU,YAAY,CAACpJ,gBAAgB,EAAE;UAC5D;UACA;UACA,MAAMiO,cAAc,GAAG,IAAI,CAAC7E,YAAY,CAACvI,OAAO,EAAEqN,IAAI,CAAC1O,MAAM,IAAIA,MAAM,CAAC2O,QAAQ,CAAC;UACjF,IAAIF,cAAc,EAAE;YAChB,MAAMG,OAAO,GAAG,IAAI,CAACC,gBAAgB,CAACJ,cAAc,CAAC7N,KAAK,CAAC;YAC3D,IAAIA,KAAK,KAAKgO,OAAO,EAAE;cACnBH,cAAc,CAACK,QAAQ,CAAC,KAAK,CAAC;YAClC;UACJ;QACJ;QACA,IAAI,IAAI,CAACb,QAAQ,CAAC,CAAC,IAAI,IAAI,CAAC1F,SAAS,CAACU,aAAa,KAAK3F,KAAK,CAAC+K,MAAM,EAAE;UAClE;UACA;UACA;UACA;UACA;UACA,MAAMU,aAAa,GAAG,IAAI,CAACnB,mBAAmB,IAAI,IAAI,CAAC5F,QAAQ,CAAC/G,aAAa,CAACL,KAAK;UACnF,IAAI,CAACgN,mBAAmB,GAAG,IAAI;UAC/B,IAAI,CAACpC,kBAAkB,CAACuD,aAAa,CAAC;QAC1C;MACJ;IACJ;IACAC,YAAYA,CAAA,EAAG;MACX,IAAI,CAAC,IAAI,CAAClG,mBAAmB,EAAE;QAC3B,IAAI,CAACA,mBAAmB,GAAG,IAAI;MACnC,CAAC,MACI,IAAI,IAAI,CAACmF,QAAQ,CAAC,CAAC,EAAE;QACtB,IAAI,CAACM,cAAc,GAAG,IAAI,CAACvG,QAAQ,CAAC/G,aAAa,CAACL,KAAK;QACvD,IAAI,CAACqO,cAAc,CAAC,IAAI,CAACV,cAAc,CAAC;QACxC,IAAI,CAACW,WAAW,CAAC,IAAI,CAAC;MAC1B;IACJ;IACAC,YAAYA,CAAA,EAAG;MACX,IAAI,IAAI,CAAClB,QAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC/E,SAAS,EAAE;QACpC,IAAI,CAACsC,kBAAkB,CAAC,CAAC;MAC7B;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;IACI0D,WAAWA,CAACE,aAAa,GAAG,KAAK,EAAE;MAC/B,IAAI,IAAI,CAAC9G,UAAU,IAAI,IAAI,CAACA,UAAU,CAAC+G,UAAU,KAAK,MAAM,EAAE;QAC1D,IAAID,aAAa,EAAE;UACf,IAAI,CAAC9G,UAAU,CAACgH,oBAAoB,CAAC,CAAC;QAC1C,CAAC,MACI;UACD,IAAI,CAAChH,UAAU,CAAC+G,UAAU,GAAG,QAAQ;QACzC;QACA,IAAI,CAAC3G,sBAAsB,GAAG,IAAI;MACtC;IACJ;IACA;IACAgD,WAAWA,CAAA,EAAG;MACV,IAAI,IAAI,CAAChD,sBAAsB,EAAE;QAC7B,IAAI,IAAI,CAACJ,UAAU,EAAE;UACjB,IAAI,CAACA,UAAU,CAAC+G,UAAU,GAAG,MAAM;QACvC;QACA,IAAI,CAAC3G,sBAAsB,GAAG,KAAK;MACvC;IACJ;IACA;AACJ;AACA;AACA;IACI6G,0BAA0BA,CAAA,EAAG;MACzB,MAAMC,aAAa,GAAG,IAAIpR,UAAU,CAACqR,UAAU,IAAI;QAC/C1V,eAAe,CAAC,MAAM;UAClB0V,UAAU,CAAC9T,IAAI,CAAC,CAAC;QACrB,CAAC,EAAE;UAAE+T,QAAQ,EAAE,IAAI,CAAClG;QAAU,CAAC,CAAC;MACpC,CAAC,CAAC;MACF,MAAMmG,aAAa,GAAG,IAAI,CAAC/F,YAAY,CAACvI,OAAO,CAACwI,OAAO,CAACC,IAAI,CAACzK,GAAG,CAAC,MAAM,IAAI,CAAC2L,iBAAiB,CAAC4E,mBAAmB,CAAC,CAAC,CAAC;MACpH;MACA;MACAtQ,KAAK,CAAC,CAAC,CAAC,CAAC;MACT;MACA,OAAQrB,KAAK,CAACuR,aAAa,EAAEG,aAAa,CAAC,CACtC7F,IAAI;MACT;MACA;MACA5K,SAAS,CAAC,MAAM,IAAI,CAACiJ,KAAK,CAACwD,GAAG,CAAC,MAAM;QACjC;QACA;QACA;QACA,MAAMkE,OAAO,GAAG,IAAI,CAAC3G,SAAS;QAC9B,IAAI,CAACmB,gBAAgB,CAAC,CAAC;QACvB,IAAI,CAAC2B,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACnL,kBAAkB,CAACoL,aAAa,CAAC,CAAC;QACvC,IAAI,IAAI,CAAC/C,SAAS,EAAE;UAChB,IAAI,CAACgC,WAAW,CAACC,cAAc,CAAC,CAAC;QACrC;QACA,IAAI0E,OAAO,KAAK,IAAI,CAAC3G,SAAS,EAAE;UAC5B;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAI,IAAI,CAACA,SAAS,EAAE;YAChB,IAAI,CAAC4G,WAAW,CAAC,CAAC;UACtB,CAAC,MACI;YACD,IAAI,CAAClG,YAAY,CAAC/H,MAAM,CAACY,IAAI,CAAC,CAAC;UACnC;QACJ;QACA,OAAO,IAAI,CAACyJ,mBAAmB;MACnC,CAAC,CAAC,CAAC;MACH;MACA3M,IAAI,CAAC,CAAC,CAAC;MACH;MAAA,CACCgD,SAAS,CAACe,KAAK,IAAI,IAAI,CAACyM,iBAAiB,CAACzM,KAAK,CAAC,CAAC;IAC1D;IACA;AACJ;AACA;AACA;IACIwM,WAAWA,CAAA,EAAG;MACV,IAAI,CAAClG,YAAY,CAAChI,MAAM,CAACa,IAAI,CAAC,CAAC;IACnC;IACA;IACA4I,aAAaA,CAAA,EAAG;MACZ,IAAI,IAAI,CAACH,WAAW,EAAE;QAClB,IAAI,CAACO,UAAU,CAAC,CAAC;QACjB,IAAI,CAACP,WAAW,CAAC8E,OAAO,CAAC,CAAC;QAC1B,IAAI,CAAC9E,WAAW,GAAG,IAAI;MAC3B;IACJ;IACA;IACA2D,gBAAgBA,CAACjO,KAAK,EAAE;MACpB,MAAMgJ,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,OAAOA,YAAY,IAAIA,YAAY,CAAClI,WAAW,GAAGkI,YAAY,CAAClI,WAAW,CAACd,KAAK,CAAC,GAAGA,KAAK;IAC7F;IACAuM,kBAAkBA,CAACvM,KAAK,EAAE;MACtB,MAAMqP,SAAS,GAAG,IAAI,CAACpB,gBAAgB,CAACjO,KAAK,CAAC;MAC9C,IAAIA,KAAK,IAAI,IAAI,EAAE;QACf,IAAI,CAAC4N,4BAA4B,CAAC,IAAI,EAAE,KAAK,CAAC;MAClD;MACA;MACA;MACA,IAAI,CAACrE,uBAAuB,CAAC8F,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAG,EAAE,CAAC;IACpE;IACA9F,uBAAuBA,CAACvJ,KAAK,EAAE;MAC3B;MACA;MACA,IAAI,IAAI,CAAC0H,UAAU,EAAE;QACjB,IAAI,CAACA,UAAU,CAAC4H,QAAQ,CAACtP,KAAK,GAAGA,KAAK;MAC1C,CAAC,MACI;QACD,IAAI,CAACoH,QAAQ,CAAC/G,aAAa,CAACL,KAAK,GAAGA,KAAK;MAC7C;MACA,IAAI,CAAC2N,cAAc,GAAG3N,KAAK;IAC/B;IACA;AACJ;AACA;AACA;AACA;IACImP,iBAAiBA,CAACzM,KAAK,EAAE;MACrB,MAAMJ,KAAK,GAAG,IAAI,CAAC0G,YAAY;MAC/B,MAAMuG,QAAQ,GAAG7M,KAAK,GAAGA,KAAK,CAACvD,MAAM,GAAG,IAAI,CAACmK,0BAA0B;MACvE,IAAIiG,QAAQ,EAAE;QACV,IAAI,CAAC3B,4BAA4B,CAAC2B,QAAQ,CAAC;QAC3C,IAAI,CAAChD,kBAAkB,CAACgD,QAAQ,CAACvP,KAAK,CAAC;QACvC;QACA;QACA;QACA,IAAI,CAACuI,SAAS,CAACgH,QAAQ,CAACvP,KAAK,CAAC;QAC9BsC,KAAK,CAACG,gBAAgB,CAAC8M,QAAQ,CAAC;QAChC,IAAI,CAACnI,QAAQ,CAAC/G,aAAa,CAACmP,KAAK,CAAC,CAAC;MACvC,CAAC,MACI,IAAIlN,KAAK,CAAC1C,gBAAgB,IAC3B,IAAI,CAACwH,QAAQ,CAAC/G,aAAa,CAACL,KAAK,KAAK,IAAI,CAACyP,cAAc,EAAE;QAC3D,IAAI,CAAC7B,4BAA4B,CAAC,IAAI,CAAC;QACvC,IAAI,CAACrB,kBAAkB,CAAC,IAAI,CAAC;QAC7B;QACA;QACA,IAAIjK,KAAK,CAACxH,cAAc,EAAE;UACtBwH,KAAK,CAACxH,cAAc,CAACoO,IAAI,CAACvK,IAAI,CAAC,CAAC,CAAC,CAAC,CAACgD,SAAS,CAAC,MAAM,IAAI,CAAC4G,SAAS,CAAC,IAAI,CAAC,CAAC;QAC5E,CAAC,MACI;UACD,IAAI,CAACA,SAAS,CAAC,IAAI,CAAC;QACxB;MACJ;MACA,IAAI,CAACsC,UAAU,CAAC,CAAC;IACrB;IACA;AACJ;AACA;IACI+C,4BAA4BA,CAAC8B,IAAI,EAAEC,SAAS,EAAE;MAC1C;MACA;MACA,IAAI,CAAC3G,YAAY,EAAEvI,OAAO,EAAEmP,OAAO,CAACxQ,MAAM,IAAI;QAC1C,IAAIA,MAAM,KAAKsQ,IAAI,IAAItQ,MAAM,CAAC2O,QAAQ,EAAE;UACpC3O,MAAM,CAAC8O,QAAQ,CAACyB,SAAS,CAAC;QAC9B;MACJ,CAAC,CAAC;IACN;IACA/E,kBAAkBA,CAACuD,aAAa,GAAG,IAAI,CAAC/G,QAAQ,CAAC/G,aAAa,CAACL,KAAK,EAAE;MAClE,IAAI,CAACqO,cAAc,CAACF,aAAa,CAAC;MAClC,IAAI,CAACG,WAAW,CAAC,CAAC;MAClB;MACA,IAAI,IAAI,CAAC1E,aAAa,EAAE;QACpB,MAAMiG,OAAO,GAAG,IAAI,CAAC7G,YAAY,CAAC7N,EAAE;QACpCsB,mBAAmB,CAAC,IAAI,CAACmN,aAAa,EAAE,WAAW,EAAEiG,OAAO,CAAC;MACjE;IACJ;IACAxB,cAAcA,CAACF,aAAa,EAAE;MAC1B,IAAI,CAAC,IAAI,CAACnF,YAAY,KAAK,OAAO/C,SAAS,KAAK,WAAW,IAAIA,SAAS,CAAC,EAAE;QACvE,MAAMS,mCAAmC,CAAC,CAAC;MAC/C;MACA,IAAIoJ,UAAU,GAAG,IAAI,CAACxF,WAAW;MACjC,IAAI,CAACwF,UAAU,EAAE;QACb,IAAI,CAACC,OAAO,GAAG,IAAI9R,cAAc,CAAC,IAAI,CAAC+K,YAAY,CAAC1E,QAAQ,EAAE,IAAI,CAACgD,iBAAiB,EAAE;UAClFnM,EAAE,EAAE,IAAI,CAACuM,UAAU,EAAEsI,UAAU,CAAC;QACpC,CAAC,CAAC;QACFF,UAAU,GAAG,IAAI,CAACzI,QAAQ,CAAC4I,MAAM,CAAC,IAAI,CAACC,iBAAiB,CAAC,CAAC,CAAC;QAC3D,IAAI,CAAC5F,WAAW,GAAGwF,UAAU;QAC7B,IAAI,CAAC/H,qBAAqB,GAAG,IAAI,CAACH,cAAc,CAAClG,MAAM,CAAC,CAAC,CAACC,SAAS,CAAC,MAAM;UACtE,IAAI,IAAI,CAAC2G,SAAS,IAAIwH,UAAU,EAAE;YAC9BA,UAAU,CAACK,UAAU,CAAC;cAAEC,KAAK,EAAE,IAAI,CAACC,cAAc,CAAC;YAAE,CAAC,CAAC;UAC3D;QACJ,CAAC,CAAC;QACF;QACA;QACA,IAAI,CAACpI,6BAA6B,GAAG,IAAI,CAACD,mBAAmB,CACxDsI,OAAO,CAACtS,WAAW,CAACuS,gBAAgB,CAAC,CACrC5O,SAAS,CAAC6O,MAAM,IAAI;UACrB,MAAMC,kBAAkB,GAAGD,MAAM,CAACE,OAAO;UACzC;UACA;UACA,IAAID,kBAAkB,EAAE;YACpB,IAAI,CAACrG,iBAAiB,CACjBuG,sBAAsB,CAAC,IAAI,CAAC,CAC5BC,iBAAiB,CAAC,IAAI,CAAC,CACvBC,kBAAkB,CAAC,CAAC,CAAC;UAC9B,CAAC,MACI;YACD,IAAI,CAACzG,iBAAiB,CACjBuG,sBAAsB,CAAC,KAAK,CAAC,CAC7BC,iBAAiB,CAAC,KAAK,CAAC,CACxBC,kBAAkB,CAAC,CAAC,CAAC;UAC9B;QACJ,CAAC,CAAC;MACN,CAAC,MACI;QACD;QACA,IAAI,CAACzG,iBAAiB,CAAC0G,SAAS,CAAC,IAAI,CAACC,oBAAoB,CAAC,CAAC,CAAC;QAC7DjB,UAAU,CAACK,UAAU,CAAC;UAAEC,KAAK,EAAE,IAAI,CAACC,cAAc,CAAC;QAAE,CAAC,CAAC;MAC3D;MACA,IAAIP,UAAU,IAAI,CAACA,UAAU,CAAC7E,WAAW,CAAC,CAAC,EAAE;QACzC6E,UAAU,CAACkB,MAAM,CAAC,IAAI,CAACjB,OAAO,CAAC;QAC/B,IAAI,CAACN,cAAc,GAAGtB,aAAa;QACnC,IAAI,CAACnB,mBAAmB,GAAG,IAAI;QAC/B,IAAI,CAAC7B,2BAA2B,GAAG,IAAI,CAACwD,0BAA0B,CAAC,CAAC;MACxE;MACA,MAAMM,OAAO,GAAG,IAAI,CAAC3G,SAAS;MAC9B,IAAI,CAACU,YAAY,CAAClJ,OAAO,GAAG,IAAI,CAACgJ,gBAAgB,GAAG,IAAI;MACxD,IAAI,CAACE,YAAY,CAACgC,qBAAqB,GAAG,IAAI;MAC9C,IAAI,CAAChC,YAAY,CAACjJ,SAAS,CAAC,IAAI,CAAC2H,UAAU,EAAEuJ,KAAK,CAAC;MACnD,IAAI,CAAC7F,iBAAiB,CAAC,CAAC;MACxB,IAAI,CAAC8F,yBAAyB,CAAC,CAAC;MAChC;MACA;MACA,IAAI,IAAI,CAAC5I,SAAS,IAAI2G,OAAO,KAAK,IAAI,CAAC3G,SAAS,EAAE;QAC9C,IAAI,CAAC4G,WAAW,CAAC,CAAC;MACtB;IACJ;IACA;IACA9D,iBAAiBA,CAAA,EAAG;MAChB,IAAI,CAACpC,YAAY,CAACjH,cAAc,CAAC,CAAC;MAClC;MACA;MACA;MACA,IAAI,IAAI,CAACuG,SAAS,EAAE;QAChB,MAAMwH,UAAU,GAAG,IAAI,CAACxF,WAAW;QACnC,IAAI,CAAC,IAAI,CAAC6G,oBAAoB,EAAE;UAC5B;UACA;UACA,IAAI,CAACA,oBAAoB,GAAGrB,UAAU,CAACsB,aAAa,CAAC,CAAC,CAACzP,SAAS,CAAC,IAAI,CAACyH,mBAAmB,CAAC;QAC9F;QACA,IAAI,CAAC,IAAI,CAACiI,yBAAyB,EAAE;UACjC;UACA;UACA;UACA,IAAI,CAACA,yBAAyB,GAAGvB,UAAU,CAACwB,oBAAoB,CAAC,CAAC,CAAC3P,SAAS,CAAC,CAAC;QAClF;MACJ,CAAC,MACI;QACD,IAAI,CAACwP,oBAAoB,EAAEjP,WAAW,CAAC,CAAC;QACxC,IAAI,CAACmP,yBAAyB,EAAEnP,WAAW,CAAC,CAAC;QAC7C,IAAI,CAACiP,oBAAoB,GAAG,IAAI,CAACE,yBAAyB,GAAG,IAAI;MACrE;IACJ;IACAnB,iBAAiBA,CAAA,EAAG;MAChB,OAAO,IAAI7T,aAAa,CAAC;QACrBkV,gBAAgB,EAAE,IAAI,CAACC,mBAAmB,CAAC,CAAC;QAC5ChK,cAAc,EAAE,IAAI,CAACqC,eAAe,CAAC,CAAC;QACtCuG,KAAK,EAAE,IAAI,CAACC,cAAc,CAAC,CAAC;QAC5BoB,SAAS,EAAE,IAAI,CAAChK,IAAI,IAAIiK,SAAS;QACjCC,UAAU,EAAE,IAAI,CAACjR,SAAS,EAAEkR;MAChC,CAAC,CAAC;IACN;IACAJ,mBAAmBA,CAAA,EAAG;MAClB;MACA,MAAMK,QAAQ,GAAG,IAAI,CAACxK,QAAQ,CACzBoB,QAAQ,CAAC,CAAC,CACVqJ,mBAAmB,CAAC,IAAI,CAACf,oBAAoB,CAAC,CAAC,CAAC,CAChDJ,sBAAsB,CAAC,KAAK,CAAC,CAC7BoB,QAAQ,CAAC,KAAK,CAAC;MACpB,IAAI,CAAC1H,qBAAqB,CAACwH,QAAQ,CAAC;MACpC,IAAI,CAACzH,iBAAiB,GAAGyH,QAAQ;MACjC,OAAOA,QAAQ;IACnB;IACA;IACAxH,qBAAqBA,CAACkH,gBAAgB,EAAE;MACpC;MACA;MACA,MAAMS,cAAc,GAAG,CACnB;QAAEC,OAAO,EAAE,OAAO;QAAEC,OAAO,EAAE,QAAQ;QAAEC,QAAQ,EAAE,OAAO;QAAEC,QAAQ,EAAE;MAAM,CAAC,EAC3E;QAAEH,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAE,QAAQ;QAAEC,QAAQ,EAAE,KAAK;QAAEC,QAAQ,EAAE;MAAM,CAAC,CAC1E;MACD;MACA;MACA;MACA,MAAMT,UAAU,GAAG,IAAI,CAAC9I,WAAW;MACnC,MAAMwJ,cAAc,GAAG,CACnB;QAAEJ,OAAO,EAAE,OAAO;QAAEC,OAAO,EAAE,KAAK;QAAEC,QAAQ,EAAE,OAAO;QAAEC,QAAQ,EAAE,QAAQ;QAAET;MAAW,CAAC,EACvF;QAAEM,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAE,KAAK;QAAEC,QAAQ,EAAE,KAAK;QAAEC,QAAQ,EAAE,QAAQ;QAAET;MAAW,CAAC,CACtF;MACD,IAAIW,SAAS;MACb,IAAI,IAAI,CAAC7J,QAAQ,KAAK,OAAO,EAAE;QAC3B6J,SAAS,GAAGD,cAAc;MAC9B,CAAC,MACI,IAAI,IAAI,CAAC5J,QAAQ,KAAK,OAAO,EAAE;QAChC6J,SAAS,GAAGN,cAAc;MAC9B,CAAC,MACI;QACDM,SAAS,GAAG,CAAC,GAAGN,cAAc,EAAE,GAAGK,cAAc,CAAC;MACtD;MACAd,gBAAgB,CAACgB,aAAa,CAACD,SAAS,CAAC;IAC7C;IACAvB,oBAAoBA,CAAA,EAAG;MACnB,IAAI,IAAI,CAAC/E,WAAW,EAAE;QAClB,OAAO,IAAI,CAACA,WAAW,CAAC7F,UAAU;MACtC;MACA,OAAO,IAAI,CAACuB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACoE,yBAAyB,CAAC,CAAC,GAAG,IAAI,CAAC1E,QAAQ;IACxF;IACAiJ,cAAcA,CAAA,EAAG;MACb,OAAO,IAAI,CAACrH,YAAY,CAACtE,UAAU,IAAI,IAAI,CAAC8N,aAAa,CAAC,CAAC;IAC/D;IACA;IACAA,aAAaA,CAAA,EAAG;MACZ,OAAO,IAAI,CAACzB,oBAAoB,CAAC,CAAC,CAAC1Q,aAAa,CAACoS,qBAAqB,CAAC,CAAC,CAACrC,KAAK;IAClF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;IACI3G,gBAAgBA,CAAA,EAAG;MACf,MAAMT,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,IAAIA,YAAY,CAACvJ,qBAAqB,EAAE;QACpC;QACA;QACA;QACA,IAAIiT,uBAAuB,GAAG,CAAC,CAAC;QAChC,KAAK,IAAI9Q,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGoH,YAAY,CAACvI,OAAO,CAAC+B,MAAM,EAAEZ,KAAK,EAAE,EAAE;UAC9D,MAAMxC,MAAM,GAAG4J,YAAY,CAACvI,OAAO,CAACkS,GAAG,CAAC/Q,KAAK,CAAC;UAC9C,IAAI,CAACxC,MAAM,CAACyN,QAAQ,EAAE;YAClB6F,uBAAuB,GAAG9Q,KAAK;YAC/B;UACJ;QACJ;QACAoH,YAAY,CAAC1H,WAAW,CAACsR,aAAa,CAACF,uBAAuB,CAAC;MACnE,CAAC,MACI;QACD1J,YAAY,CAAC1H,WAAW,CAACsR,aAAa,CAAC,CAAC,CAAC,CAAC;MAC9C;IACJ;IACA;IACAvF,QAAQA,CAAA,EAAG;MACP,MAAMwF,OAAO,GAAG,IAAI,CAACzL,QAAQ,CAAC/G,aAAa;MAC3C,OAAO,CAACwS,OAAO,CAACC,QAAQ,IAAI,CAACD,OAAO,CAAChG,QAAQ,IAAI,CAAC,IAAI,CAACkG,oBAAoB;IAC/E;IACA;IACA/I,UAAUA,CAAA,EAAG;MACT,OAAO,IAAI,CAACrC,SAAS,EAAEqL,WAAW,IAAIjJ,MAAM;IAChD;IACA;IACAuD,eAAeA,CAAC1L,KAAK,EAAE;MACnB;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMoH,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,MAAMiK,UAAU,GAAGtZ,6BAA6B,CAACiI,KAAK,EAAEoH,YAAY,CAACvI,OAAO,EAAEuI,YAAY,CAAC9E,YAAY,CAAC;MACxG,IAAItC,KAAK,KAAK,CAAC,IAAIqR,UAAU,KAAK,CAAC,EAAE;QACjC;QACA;QACA;QACAjK,YAAY,CAAC5G,aAAa,CAAC,CAAC,CAAC;MACjC,CAAC,MACI,IAAI4G,YAAY,CAAC1G,KAAK,EAAE;QACzB,MAAMlD,MAAM,GAAG4J,YAAY,CAACvI,OAAO,CAACqB,OAAO,CAAC,CAAC,CAACF,KAAK,CAAC;QACpD,IAAIxC,MAAM,EAAE;UACR,MAAMyT,OAAO,GAAGzT,MAAM,CAAC8T,eAAe,CAAC,CAAC;UACxC,MAAMC,iBAAiB,GAAGvZ,wBAAwB,CAACiZ,OAAO,CAACO,SAAS,EAAEP,OAAO,CAACQ,YAAY,EAAErK,YAAY,CAACzG,aAAa,CAAC,CAAC,EAAEyG,YAAY,CAAC1G,KAAK,CAACjC,aAAa,CAACgT,YAAY,CAAC;UACxKrK,YAAY,CAAC5G,aAAa,CAAC+Q,iBAAiB,CAAC;QACjD;MACJ;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIjC,yBAAyBA,CAAA,EAAG;MACxB;MACA;MACA;MACA;MACA;MACA;MACA,MAAMoC,KAAK,GAAG,IAAI,CAAClM,QAAQ,CAAC/G,aAAa,CAACkT,OAAO,CAAC,mDAAmD,CAAC;MACtG,IAAI,CAACD,KAAK,EAAE;QACR;QACA;MACJ;MACA,MAAMzD,OAAO,GAAG,IAAI,CAAC7G,YAAY,CAAC7N,EAAE;MACpC,IAAI,IAAI,CAACyO,aAAa,EAAE;QACpBpN,sBAAsB,CAAC,IAAI,CAACoN,aAAa,EAAE,WAAW,EAAEiG,OAAO,CAAC;MACpE;MACApT,mBAAmB,CAAC6W,KAAK,EAAE,WAAW,EAAEzD,OAAO,CAAC;MAChD,IAAI,CAACjG,aAAa,GAAG0J,KAAK;IAC9B;IACA;IACA5I,eAAeA,CAAA,EAAG;MACd,IAAI,IAAI,CAACd,aAAa,EAAE;QACpB,MAAMiG,OAAO,GAAG,IAAI,CAAC7G,YAAY,CAAC7N,EAAE;QACpCqB,sBAAsB,CAAC,IAAI,CAACoN,aAAa,EAAE,WAAW,EAAEiG,OAAO,CAAC;QAChE,IAAI,CAACjG,aAAa,GAAG,IAAI;MAC7B;IACJ;IAAC,QAAA9G,CAAA,GACQ,IAAI,CAACC,IAAI,YAAAyQ,+BAAAvQ,iBAAA;MAAA,YAAAA,iBAAA,IAA+FuD,sBAAsB,EA13BhCtO,EAAE,CAAAgL,iBAAA,CA03BgDhL,EAAE,CAACkL,UAAU,GA13B/DlL,EAAE,CAAAgL,iBAAA,CA03B0E/G,IAAI,CAACC,OAAO,GA13BxFlE,EAAE,CAAAgL,iBAAA,CA03BmGhL,EAAE,CAACub,gBAAgB,GA13BxHvb,EAAE,CAAAgL,iBAAA,CA03BmIhL,EAAE,CAACwb,MAAM,GA13B9Ixb,EAAE,CAAAgL,iBAAA,CA03ByJhL,EAAE,CAACiL,iBAAiB,GA13B/KjL,EAAE,CAAAgL,iBAAA,CA03B0L0D,gCAAgC,GA13B5N1O,EAAE,CAAAgL,iBAAA,CA03BuOtE,EAAE,CAAC+U,cAAc,MA13B1Pzb,EAAE,CAAAgL,iBAAA,CA03BqR9E,cAAc,MA13BrSlG,EAAE,CAAAgL,iBAAA,CA03B4UnH,QAAQ,MA13BtV7D,EAAE,CAAAgL,iBAAA,CA03BiXjH,EAAE,CAAC2X,aAAa,GA13BnY1b,EAAE,CAAAgL,iBAAA,CA03B8Y7D,gCAAgC;IAAA,CAA4D;IAAA,QAAAiE,EAAA,GAC1kB,IAAI,CAAC+C,IAAI,kBA33BqFnO,EAAE,CAAAoO,iBAAA;MAAA7C,IAAA,EA23BJ+C,sBAAsB;MAAA9C,SAAA;MAAAc,SAAA;MAAAqP,QAAA;MAAAC,YAAA,WAAAC,oCAAA7Z,EAAA,EAAAC,GAAA;QAAA,IAAAD,EAAA;UA33BpBhC,EAAE,CAAAqC,UAAA,qBAAAyZ,kDAAA;YAAA,OA23BJ7Z,GAAA,CAAAiU,YAAA,CAAa,CAAC;UAAA,CAAO,CAAC,kBAAA6F,+CAAA;YAAA,OAAtB9Z,GAAA,CAAAqO,UAAA,CAAW,CAAC;UAAA,CAAS,CAAC,mBAAA0L,gDAAAzZ,MAAA;YAAA,OAAtBN,GAAA,CAAAqT,YAAA,CAAA/S,MAAmB,CAAC;UAAA,CAAC,CAAC,qBAAA0Z,kDAAA1Z,MAAA;YAAA,OAAtBN,GAAA,CAAA2S,cAAA,CAAArS,MAAqB,CAAC;UAAA,CAAD,CAAC,mBAAA2Z,gDAAA;YAAA,OAAtBja,GAAA,CAAAoU,YAAA,CAAa,CAAC;UAAA,CAAO,CAAC;QAAA;QAAA,IAAArU,EAAA;UA33BpBhC,EAAE,CAAAyD,WAAA,iBAAAxB,GAAA,CAAAuO,qBAAA,UAAAvO,GAAA,CAAA4Y,oBAAA,GA23BmB,IAAI,GAAG,UAAU,uBAAA5Y,GAAA,CAAA4Y,oBAAA,GAAjB,IAAI,GAAG,MAAM,2BAAA5Y,GAAA,CAAAmO,SAAA,IAAAnO,GAAA,CAAAuR,YAAA,GAAAvR,GAAA,CAAAuR,YAAA,CAAAvQ,EAAA,GAAY,IAAI,mBAAAhB,GAAA,CAAA4Y,oBAAA,GAA7B,IAAI,GAAG5Y,GAAA,CAAAmO,SAAA,CAAA+L,QAAA,CAAmB,CAAC,mBAAAla,GAAA,CAAA4Y,oBAAA,KAAA5Y,GAAA,CAAAmO,SAAA,GAAX,IAAI,GAAAnO,GAAA,CAAA6O,YAAA,kBAAA7O,GAAA,CAAA6O,YAAA,CAAA7N,EAAA,mBAAAhB,GAAA,CAAA4Y,oBAAA,GAApB,IAAI,GAAG,SAAS;QAAA;MAAA;MAAAtO,MAAA;QAAAuE,YAAA;QAAAP,QAAA;QAAAuD,WAAA;QAAAtD,qBAAA;QAAAqK,oBAAA,yDAA4X1a,gBAAgB;MAAA;MAAAwM,QAAA;MAAAC,UAAA;MAAAC,QAAA,GA33Bjb7M,EAAE,CAAA8M,kBAAA,CA23BwpC,CAACuB,+BAA+B,CAAC,GA33B3rCrO,EAAE,CAAAiN,wBAAA,EAAFjN,EAAE,CAAAoc,oBAAA;IAAA,EA23BqwC;EACl3C;EAAC,OApwBK9N,sBAAsB;AAAA;AAqwB5B;EAAA,QAAAP,SAAA,oBAAAA,SAAA;AAAA;AA8DoB,IAEdsO,qBAAqB;EAA3B,MAAMA,qBAAqB,CAAC;IAAA,QAAAzR,CAAA,GACf,IAAI,CAACC,IAAI,YAAAyR,8BAAAvR,iBAAA;MAAA,YAAAA,iBAAA,IAA+FsR,qBAAqB;IAAA,CAAkD;IAAA,QAAAjR,EAAA,GAC/K,IAAI,CAACmR,IAAI,kBA/7BqFvc,EAAE,CAAAwc,gBAAA;MAAAjR,IAAA,EA+7BS8Q;IAAqB,EAWtG;IAAA,QAAAI,EAAA,GACxB,IAAI,CAACC,IAAI,kBA38BqF1c,EAAE,CAAA2c,gBAAA;MAAAC,SAAA,EA28B2C,CAAC7N,iDAAiD,CAAC;MAAA8N,OAAA,GAAYzY,aAAa,EACxNzC,eAAe,EACfC,eAAe,EACfkC,YAAY,EAAEE,mBAAmB,EACjCrC,eAAe,EACfC,eAAe;IAAA,EAAI;EAC/B;EAAC,OApBKya,qBAAqB;AAAA;AAqB3B;EAAA,QAAAtO,SAAA,oBAAAA,SAAA;AAAA;;AAwBA;AACA;AACA;;AAEA,SAAS5G,gCAAgC,EAAEG,wCAAwC,EAAEoH,gCAAgC,EAAEI,wCAAwC,EAAEC,iDAAiD,EAAEV,+BAA+B,EAAE1G,eAAe,EAAE0U,qBAAqB,EAAErO,qBAAqB,EAAEjH,4BAA4B,EAAEuH,sBAAsB,EAAEE,mCAAmC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}